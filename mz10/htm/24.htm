<html><head><meta http-equiv=Content-Type content="text/html; charset=iso-8859-2"><link rel=stylesheet href=magazin.css TYPE=text/css><title>MagaZin #10 :: maj 2002</title></head><body link=#478DE7 vlink=#478DE7 alink=#478DE7 topmargin=0 bottommargin=0 bgcolor=#000000><div align=center><center><table border=0 width=650 style="border-style: solid; border-width: 0" cellspacing=0 cellpadding=0 height=100% bgcolor=#FFFFFF><tr><td width=100% height=20 valign=top></td></tr></center><tr><td width=100% height=25 valign=middle bgcolor=#4048A8><div align=center><table border=0 width=583 cellspacing=0 cellpadding=0><center><td width=400 class=9ptV valign=bottom colspan=3><p class=9ptV><font color=#FFFFFF><b>MAGAZIN #10 :: STRONA 24</b></font></td></center><td width=133 class=9ptV valign=bottom><p align=right><font color=#FFFFFF><img border=0 src=../img/direct.gif width=7 height=10><img border=0 src=../img/direct3.gif width=7 height=10><img border=0 src=../img/direct2.gif width=7 height=10></font></td><center><td width=8 class=9ptV valign=bottom></td><td width=55 class=9ptV><b><font color=#FFFFFF>KOMPUTER</font></b></td></table></center></div></td></tr><center><tr><td width=100% height=5 valign=top><p class=9ptV>&nbsp;</td></tr><tr><td width=100% height=20 valign=bottom><div align=center><table border=0 width=586 height=20 cellspacing=0 cellpadding=0><tr><td width=135 background=../img/line3.gif><p align=right><img border=0 src=../img/line.gif width=9 height=20></td><td width=310 valign=bottom><p align=center class=9ptV><a href=23.htm class=link2><font color=#4048A8>poprzednia strona</font></a><font color=#4048A8>:: </font><a href=spis.htm class=link2><font color=#4048A8>spis tre¶ci</font></a><font color=#4048A8>:: </font><a href=25.htm class=link2><font color=#4048A8>nastêpna strona</font></a></td><td width=135 background=../img/line3.gif><img border=0 src=../img/line2.gif width=9 height=20></td></tr></table></div></td></tr></center><center><tr><td width=100% height=5 valign=top><p class=9ptV>&nbsp;</td></tr><tr><td width=100% height=21 valign=top><div align=center><center><table border=0 width=600 cellspacing=0 cellpadding=6 height=20 bgcolor=#FFFFFF><tr><td width=285 height=20 valign=top class=9pt><div align=center><center><table border=0 width=100% cellspacing=0 cellpadding=0><tr><td width=100% valign=top class=9ptV height=15><i>Software</i></td></tr><tr><td width=100%><p class=u>Kurs Delphi #1</td></tr></table></center></div><p class=9ptV align=justify><b>Wstêp</b><br> <br> Witam i zapraszam do kursu Delphi napisanego przeze mnie. :) My¶lê, ¿e jednak co¶ umiem w tym Delphi i dlatego postanowi³em napisaæ kursik (nie sugerujcie siê zdrobnieniem, bo raczej ma³y to on nie bêdzie :)). Taak... kurs Delphi mo¿na pisaæ bardzo d³ugo i praktycznie ka¿da lekcja przyniesie co¶ nowego.<br> Ju¿ widzê Wasz zapa³ do programowania obiektowego. Tak, Delphi umo¿liwia pisanie programów wizualnie. Czyli najpierw bierzemy siê za wygl±d naszej aplikacji (rozmieszczenie okien, przycisków itp), a pó¼niej co dopiero trochê programujemy, bo Delphi ogromn± ilo¶æ rzeczy robi za nas. Dobra koniec tych nudnych wstêpów, pora siê braæ do roboty, bo chyba nie za bardzo chcecie us³yszeæ ca³± historiê o Delphi.<br> Muszê jeszcze pohamowaæ wasz zapa³ do robienia programów wizualnie. Po prostu nie cieszy³bym siê na waszym miejscu, ¿e zaraz napiszemy jakiego¶ Worda czy Super-Hiper_the_Be¶ciak_Edytora-HTML-a. Najpierw muszê was przynudziæ trochê wstêpem do programowania w Object Pascal. Tak, Delphi jest oparte na jêzyku Object Pascal, który jest bardzo podobny do Pascala i wielu z was mo¿e siê trochê nudziæ. Radzê jednak dla pascalowców przeczytaæ ten dwie-trzy lekcje Object Pascala, bo ja te¿ zaczyna³em od Pascala i pó¼niej mia³em trochê problemów przy przej¶ciu na Delphi (kilka rzeczy jest trochê innych). Np.: kompilator: niestety raczej na pewno nie da siê skompilowaæ programów w Object Pascalu przy u¿yciu Turbo Pascala 7.0. Do tego pos³u¿y nam... Delphi! :) Wersja najlepiej 5, ale prze¿yjecie te¿ na 3 i 4. Odradzam do tego kursu 1, 2 i 6. Jedynka i dwójka jest raczej do Windowsa poni¿ej wersji 95 :), a 6 prawie ca³kowicie ró¿ni siê od swoich poprzedniczek. Jeszcze trochê o Object Pascalu: przez wielu fachowców :) jest uwa¿any za równego C++, a nawet lepszego. To ju¿ sami rozprawicie, bo ja w C++ jestem raczej bardziej ni¿ ciemny. :)<br> <br> <b>Object Pascal</b><br> <br> Wiêc zaczynamy przynudzanie Object Pascalem. :) Zanim napiszemy pierwszy program: w³±czcie Delphi, pó¿niej menu Project -> Options, a na karcie Linker zaznaczcie Generate Console Application. Zamknijcie Options, zamknijcie okno Form1 i okno Unit1.pas (nie zapisujcie zmian), a w menu w³±czcie Options -> View Source. Powinni¶cie zobaczyæ co¶ takiego:<br> <br> <font color=#4048A8>program Project1;<br> <br> uses<br> Forms;<br> <br> {$R *.RES}<br> <br> begin<br> Application.Initialize;<br> Application.Run;<br> end.</font><br> <br> Je¶li macie Delphi 2, 4, 5 lub 6 to powinni¶cie na 100% to zobaczyæ (w innych nie jestem pewien). No, wiêc czas na pierwszy program, a pó¼niej jakie¶ wyja¶nienia:<br> <br> <font color=#4048A8>program Project1;<br> <br> uses<br> Forms;<br> <br> begin<br> writeln('Hello world!');<br> readln;<br> end.&nbsp;</font><br> <br> Na pocz±tek uruchomcie program (Run -> Run) i zobaczcie co nam wysz³o. Ju¿ wrócili¶cie? :) Teraz wyt³umaczymy sobie wszystko po kolei:<br> <br> <b>program Project1;</b> - rozpoczyna nasz program i podaje nazwê pliku (Project1). Nazwa musi byæ bez polskich znaków i znaków typu !%$. Aby zmieniæ nazwê pliku musimy zapisaæ nasz program na dysk pod chcian± nazw± (pierwszy.dpr). Ka¿d± instrukcjê kodu koñczymy znakiem ";".<br> <br> <b>uses Forms;</b> - tutaj podajemy nazwy modu³ów, z których korzysta nasza aplikacja (w tym przypadku Forms). Mogli¶my dodaæ ich wiêcej (uses Forms, Buttons;), ale na tym poziomie nie bêdziemy z nich korzystaæ. O modu³ach jeszcze napiszê dok³adniej, na razie starczy Wam to: w modu³ach s± zapisane procedury i funkcje, z których mo¿emy korzystaæ do woli (oby poprawnie :)). Acha ¶rednik wstawiamy po wymienieniu wszystkich modu³ów, a poszczególne nazwy modu³ów oddzielamy przecinkiem.<br> <br> <b>begin</b> - to s³owo zaczyna nasz program. W tym miejscu znajduje siê g³ówny kod programu, uruchomienie programu powoduje wykonanie wszystkich operacji zawartych pomiêdzy s³owem begin a end.<br> <br> <b>writeln('Hello world');</b> - tutaj spotykamy siê z pierwsz± instrukcj± jak± ka¿emy wykonaæ programowi. Jest to procedura o deklaracji writeln(S: String); Powoduje wy¶wietlenie tekstu, który znajduje siê po nawiasach w apostrofach. Mogli¶my napisaæ te¿ tak: writeln('Witaj Romek!'); Tutaj mo¿emy pisaæ ka¿dy znak: polski czy z typu !@#$$%^&amp;*()_+ byle w apostrofach. Apostrofy mówi±, w którym miejscu zaczyna siê tekst do wy¶wietlenie i gdzie siê koñczy. Od razu nasuwa siê pytanie: a jak wy¶wietliæ apostrof, bo gdy napiszemy tak: wrtieln('What's up?'); to bêdzie b³±d. W Delphi s± na to co najmniej dwa sposoby: poprzez pisanie w kodzie ASCII (to pominiemy chwilowo) oraz tak: writeln('What''s up?'); Jak zauwa¿yli¶cie to zadzia³a, mówi±c krótko: dwa apostrofy obok siebie nie koñcz± wpisywania tekstu tylko wy¶wietlaj± jeden apostrof. Dla zrozumienia jeszcze jeden przyk³ad: writeln('I''m writing a program and they''re reading my text'); Delphi ma du¿o wspólnego z angielskim (ciekawe, nie?), ale pewnie zapytacie: sk±d siê wziê³o writeln? Ju¿ t³umaczê: koñcówka "ln" mówi programowi, ¿eby opu¶ci³ linijkê ni¿ej po napisaniu tekstu. Mogli¶my napisaæ write('co¶tam');, a wtedy program napisa³by tylko tekst nie opuszczaj±c linijki. To samo siê dotyczy procedury readln, a o tym poni¿ej.<br> <br> <b>readln;</b> - procedura powoduje, ¿e program czeka na wprowadzenie przez u¿ytkownika tekstu (z klawiatury) a¿ do naci¶niêcia Enter. Wtedy wszystko co napisali¶my zostanie podstawione pod zmienn±. Da³em t± procedurê w pierwszym programie z jednego powa¿nego powodu: Delphi w do¶æ dziwny sposób kompiluje programy konsolowe: po zrobieniu wszystkich operacji wy³±cza siê zamykaj±c okno. Przez co nie zauwa¿yliby¶cie efektu programu, a tylko jego migniêcie na pulpicie. Wiêc przy ka¿dym programie (konsolowym) na koñcu bêdê wstawia³ readln;. Mo¿na j± by³o napisaæ bez "ln" wtedy po wczytaniu zmiennej program nie przejdzie o linijkê ni¿ej. Prawdziwa deklaracja zmiennej to: read(zmienna); O prawdziwym zastosowaniu procedury read napiszê przy zmiennych.<br> <br> Muszê jeszcze napisaæ o tej koñcówce "ln" przy procedurach read i write. Przy read nie ma to du¿ego zastosowania, bo mo¿na po niej wpisaæ po prostu writeln; i po sprawie. natomiast gdyby¶my napisali tak:<br> <br> <font color=#4048A8>write('Piszemy sobie');<br> write('Czemu nie?');</font><br> <br> Otrzymaliby¶my efekt taki:<br> <br> <font color=#4048A8>Piszemy sobieCzemu nie?</font><br> <br> Teraz rozumiecie? Nie zapamiêtujcie tego na d³ugo, bo przy prawdziwym Delphi to siê nam w ogóle nie przyda.<br> <br> <b>Sta³e</b><br> <br> Sta³e s± podobne do zmiennych z jednym tylko wyj±tkiem: nie mo¿na zmieniaæ ich warto¶ci. Deklarujemy je po s³owie const, pisz±c nazwê sta³ej oraz jej warto¶æ. Je¶li podamy warto¶æ liczbow± to program automatycznie zrobi z niej sta³± liczbow±, a gdy tekst to zrobi z niej ³añcuch znaków. Mo¿e ma³y programik?<br> <br> <font color=#4048A8>program Project1;<br> <br> uses Forms;<br> <br> const tekscik='Tutaj mamy tekst ze sta³ej';<br> <br> begin<br> writeln('Tutaj mamy tekst bezpo¶rednio z procedury');<br> writeln(tekscik);<br> readln;<br> end.</font><br> <br> Uruchomcie program. Co zauwa¿yli¶cie? Program wy¶wietli³ nam dwa zdania:<br> <br> <font color=#4048A8>Tutaj mamy tekst bezpo¶rednio z procedury<br> Tutaj mamy tekst ze sta³ej</font><br> <br> Pocz±tek zrozumiany (program, uses [nie trzeba dawaæ Enteru po s³owie uses!]). Dalej ju¿ zaczynaj± siê schody:<br> <br> <b>const = 'Tutaj mamy tekst ze sta³ej';</b> - w tym miejscu stworzyli¶my sta³± z warto¶ci± "Tutaj mamy tekst ze sta³ej". Sta³a nazywa siê "tekscik" (bez polskich znaków i !@#$%$, ale mog± byæ liczby). Du¿o nam to nie daje, ale id¼my dalej.<br> begin - zrozumia³e, nie?<br> <br> <b>writeln(Tutaj mamy tekst bezpo¶rednio z procedury');</b> - tutaj napisali¶my (przy u¿yciu procedury writeln) tekst zawarty w apostrofach. Nic trudnego.<br> <br> <b>writeln(tekscik);</b> - tutaj napisali¶my... sta³±. jak zauwa¿yli¶my w nawiasach poda³em nazwê sta³ej (bez apostrofów). Dziêki temu program wy¶wietli tylko tekst zawarty w sta³ej. Teraz siê zatrzymamy. Gdy podajemy jakie¶ dane w prosty sposób (write('Prosty sposób');) to dan± warto¶æ piszemy w apostrofach, a zmienn± i sta³± bez (writeln(zmienna1);). Wyj±tkiem s± tutaj tylko liczby, które podajemy bez apostrofów (write(1234567890);) i zmienne oraz sta³e te¿ bez.<br> Reszta te¿ zrozumia³a. Idziemy do sta³ych liczbowych:<br> <br> <font color=#4048A8>program Project1;<br> <br> uses Forms;<br> <br> const rok=2002;<br> <br> begin<br> writeln('Data:');<br> writeln(rok);<br> readln;<br> end</font><br> <br> <b>const rok = 2002;</b> - tak jak pisa³em wy¿ej sta³e oraz zmienne liczbowe podajemy bez apostrofów. Tutaj sta³± nazwa³em "rok" , a jej warto¶æ to "2002".<br> <br> <b>writeln(rok);</b> - tutaj nic siê nie zmieni³o, tylko nazwa sta³ej (rok).<br> <br> Teraz jeszcze nauczmy siê wpisywaæ jedn± procedur± zwyk³y tekst oraz sta³± liczbow± i znakow±.<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> <br> const imie = 'Jan';<br> nazwisko = 'Kowalski';<br> indeks = '123456';<br> <br> begin<br> writeln('Pan/i: '+imie+' '+nazwisko+' posiada numer indeksu: '+indeks);<br> readln;<br> end.</font><br> <br> Wyja¶nienie:<br> <br> <b>const {i tak dalej}</b> - tutaj zdefiniowali¶my trzy sta³e: imie (warto¶æ: Jan), nazwisko (warto¶æ: Kowalski) oraz indeks (warto¶æ: 123456).<br> writeln('Pan/i: '+imie+' '+nazwisko+' posiada numer indeksu: '+indeks); - tutaj siê zatrzymamy. Na pocz±tku piszemy zwyk³y tekst: Pan/i, pó¼niej zamykamy go apostrofem i dajemy plus, piszemy sta³± imie, znowu plus, w apostrofach dajemy spacjê (' '), znowu plus, sta³± nazwisko, plus, tekst: posiada numer indeksu, plus i na samym koñcu sta³± liczbow± indeks. Jak zauwa¿yli¶cie zwyk³y tekst oraz sta³e oddzielamy plusami, co oznacza, ¿e dodajemy do ca³o¶ci tekstu sta³±. Miêdzy sta³ymy te¿ stawiamy plusy: writeln(imie + nazwisko + indeks);. Zwróæcie te¿ uwagê na spacje, które wstawi³em w tekstach w apostrofach, pomagaj± oddzieliæ tekst od sta³ej w koñcowym wyniku: writeln('Pan/i:'+imie+nazwisko+'posiada numer indeksu:'+indeks); otrzymamy co¶ takiego: Pan/iJanKowalskiposiada numer indeksu:123456. Nieciekawie co? Jeszcze mogli¶my zrobiæ tak:<br> <br> <font color=#4048A8>writeln('Imiê: ' + imie);<br> writeln('Nazwisko: ' + nazwisko);<br> writeln('Indeks: ' + indeks);</font><br> <br> Teraz wszystko gra. Ju¿ siê strasznie rozpisa³em, a muszê jeszcze napisaæ o zmiennych.&nbsp;<br> <br> <b>Zmienne</b><br> <br> Ze sta³ymi jest jeden powa¿ny b³±d, który zmusi³ kogo¶ do stworzenia zmiennych, mog± przyjmowaæ tylko warto¶æ na pocz±tku programu, a pó¼niej nie mo¿na jej w ¿aden sposób zmieniæ. Od tego s± w³a¶nie zmienne. Umo¿liwiaj± bowiem podstawianie pod nie warto¶ci w praktycznie dowolnym miejscu programu. Zmienne deklarujemy za pomoc± wyrazu var. Mamy kilka typów zmiennych, a zaczniemy od typów ca³kowitych, czyli liczb ca³kowitych.<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> <br> var liczba: byte;<br> <br> begin<br> liczba := 10;<br> writeln(liczba);<br> readln;<br> end.</font><br> <br> <b>var liczba: byte;</b> - tutaj stworzyli¶my zmienn± liczba typu Byte. Typ Byte jest jednym z typów liczb ca³kowitych dostêpnych w Object Pascalu.<br> liczba := 10; - tutaj podstawili¶my pod zmienn± liczba warto¶æ 10. Znak przypisu (:=) stosuje siê do przypisywania warto¶ci zmiennym, mogli¶my te¿ podstawiæ inn± warto¶æ: liczba := 53; liczba := 99; itp. Wa¿ne, ¿eby nie przekroczyæ liczby 255, a dlaczego? To ilustruje poni¿sza tabela:<br> <br><div align=center><table border=1 width=100% cellspacing=0 cellpadding=2 bordercolor=#CBCDE2><tr><td width=15% class=9ptV align=center><b>Typ</b></td><td width=38% class=9ptV align=center><b>Zakres warto¶ci</b></td><td width=47% class=9ptV align=center><b>Zajmowany rozmiar w pamiêci (bajty)&nbsp;</b></td></tr><tr><td width=15% class=9ptV align=center>Byte</td><td width=38% class=9ptV align=center>0..255</td><td width=47% class=9ptV align=center>1</td></tr><tr><td width=15% class=9ptV align=center>Word</td><td width=38% class=9ptV align=center>0..65535</td><td width=47% class=9ptV align=center>2</td></tr><tr><td width=15% class=9ptV align=center>ShortInt</td><td width=38% class=9ptV align=center>-128..127</td><td width=47% class=9ptV align=center>1</td></tr><tr><td width=15% class=9ptV align=center>SmallInt</td><td width=38% class=9ptV align=center>-32768..32767</td><td width=47% class=9ptV align=center>2</td></tr><tr><td width=15% class=9ptV align=center>Integer</td><td width=38% class=9ptV align=center>-2147483648..<br> 2147483647&nbsp;</td><td width=47% class=9ptV align=center>4</td></tr><tr><td width=15% class=9ptV align=center>Cardinal</td><td width=38% class=9ptV align=center>0..2147483648</td><td width=47% class=9ptV align=center>4</td></tr><tr><td width=15% class=9ptV align=center>Longint</td><td width=38% class=9ptV align=center>-2147483648..<br> 2147483647</td><td width=47% class=9ptV align=center>4</td></tr></table></div></td><td width=285 height=20 valign=top class=9pt><p class=9ptV align=justify>Teraz wszystko jasne? Zwróæcie uwagê, ¿e im wiêkszy przedzia³ ma dany typ (np.: Integer), tym wiêcej zajmuje bajtów w pamiêci. Chcieli¶cie zrobiæ wiêksz± liczbê, a mo¿e liczbê ujemn±? Zastosujmy wiêc typ Integer: (najczê¶ciej u¿ywany przez programistów)<br> <br> <font color=#4048A8>var x: Integer;<br> begin<br> x := 1000999;</font><br> <br> Tak samo bêdzie z reszt± typów. Teraz zajmijmy siê powa¿niejsz± spraw±. Skoro zmienne zosta³y wymy¶lone z my¶l± (fajnie mi siê powiedzia³o :)) o zmienianiu ich warto¶ci to mo¿e spróbujemy u¿yæ ich w obliczeniach? Na pocz±tek ma³a informacja:<br> <br> <b>x + y</b> dodaje liczby<br> <b>x - y</b> odejmuje liczby<br> <b>x * y</b> mno¿y liczby<br> <b>x / y</b> dzieli liczby (mozna u¿ywaæ tylko przy typach rzeczywistych, o których napiszê)<br> <b>x div y</b> dzieli liczby bez u³amków<br> <b>x mod y</b> otrzymuje warto¶æ reszty z dzielenia liczby x i y<br> <br> Teraz czas na programik, przy okazji zobaczycie jak wczytuje siê zmienne od u¿ytkownika:<br> <br> <font color=#4048A8>program Project1;<br> <br> uses Forms;<br> var<br> a, b: Integer;<br> <br> begin<br> write('Podaj liczbê a: ');<br> readln(a);<br> write('Podaj liczbê b: ');<br> readln(b);<br> write('Suma: ');<br> writeln(a + b);<br> readln;<br> end.</font><br> <br> <b>var a, b: Integer;</b> - w tym miejscu zdefiniowa³em dwie zmienne o tym samym typie (Integer), oddzielaj±c je przecinkiem. Nic nie stoi na przeszkodzie, ¿eby je zdefiniowaæ tak: var a: Integer; b: Integer;<br> <br> <b>readln(a)</b> - tutaj dziêki procedurze read oczekujemy od u¿ytkownika aby wprowadzi³ liczbê i nastêpnie zatwierdzi³a j± Enterem. To samo siê tyczy readln(b);<br> <br> <b>writeln(a + b);</b> - tutaj wypisujemy sumê zmiennej a i b. Pisz±c znak plus pomiêdzy nimi nie mia³em zamiaru wypisaæ jednej obok drugiej, tylko ich sumê. Mogli¶my te¿ zdefiniowaæ zmienn± wynik, pod któr± podstawimy warto¶æ sumy a i b. Looknijcie na nastêpny programik:<br> <br> <font color=#4048A8>program Project1;<br> <br> uses Forms;<br> var<br> a, b, wynik: Integer;<br> <br> begin<br> write('Podaj liczbê a: ');<br> readln(a);<br> write('Podaj liczbê b: ');<br> readln(b);<br> write('Suma: ');<br> wynik := a + b;<br> writeln(wynik);<br> readln;<br> end.</font><br> <br> <b>var a, b, wynik: Integer;</b> - do naszych dwóch zmiennych a i b dodali¶my zmienn± wynik.<br> <br> <b>wynik := a + b;</b> - w³a¶nie w taki sposób podstawiamy warto¶ci pod zmienn±, w tym przypadku sumê zmiennych a i b.<br> <br> <b>writeln(wynik);</b> - teraz wypisujemy wynik, pod którym jest podstawiona suma a i b.<br> <br> My¶lê, ¿e nie muszê dawaæ przyk³adów odejmowania i mno¿enia. Przejd¼my do dzielenia z reszt±:<br> <br> <font color=#4048A8>program Project1;<br> <br> uses Forms;<br> var<br> a, b, wynik, reszta: Integer;<br> <br> begin<br> write('Podaj liczbê a: ');<br> readln(a);<br> write('Podaj liczbê b: ');<br> readln(b);<br> wynik := a div b;<br> reszta := a mod b;<br> write('Iloraz: ');<br> writeln(wynik);<br> write('Reszta: ');<br> writeln(reszta);<br> readln;<br> end.</font><br> <br> <b>var a, b, wynik, reszta: Integer;</b> - dosz³a nam nowa zmienna reszta.<br> <br> <b>wynik := a div b;</b> - tutaj dzielimy a przez b bez reszty.<br> <br> <b>reszta := a mod b;</b> - tutaj obliczmy resztê z dzielenia a przez b<br> Acha, radzê za drug± liczbê (b) nie dawaæ zera, bo wtedy bêdziemy mieli b³±d: division by zero (dzielenie przez zero).&nbsp;<br> <br> Zapewne wiêkszo¶ci z Was nie zadowala dzielenie z reszt±, dlatego stworzono rzeczywisty typ zmiennych:</p><div align=center><center><table border=1 width=100% bordercolor=#CBCDE2 cellspacing=0 cellpadding=2><tr><td width=15% align=center class=9ptV><b>Typ</b></td><td width=39% align=center class=9ptV><b>Zakres warto¶ci</b></td><td width=46% align=center class=9ptV><b>Zajmowany rozmiar<br> w pamiêci (bajty)&nbsp;</b></td></tr><tr><td width=15% align=center class=9ptV>Real</td><td width=39% align=center class=9ptV>2.9*10-39..<br> 1.7*1038</td><td width=46% align=center class=9ptV>6</td></tr><tr><td width=15% align=center class=9ptV>Single</td><td width=39% align=center class=9ptV>1.5*10-45..<br> 3.4*1038</td><td width=46% align=center class=9ptV>4</td></tr><tr><td width=15% align=center class=9ptV>Double</td><td width=39% align=center class=9ptV>5.0*10-324..<br> 1.7*10308</td><td width=46% align=center class=9ptV>8</td></tr><tr><td width=15% align=center class=9ptV>Extended</td><td width=39% align=center class=9ptV>3.4*10-4932..<br> 1.1*104392</td><td width=46% align=center class=9ptV>10</td></tr></table></center></div><p class=9ptV align=justify>Poni¿ej program dziel±cy przez siebie dwie liczby:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> <br> var a, b, wynik: Real;<br> <br> begin<br> write('Podaj a: ');<br> readln(a);<br> write('Podaj b: ');<br> readln(b);<br> wynik := a/b;<br> writeln('Wynik: ', wynik:0:2);<br> readln;<br> end.</font><br> <br> <b>writeln('Wynik: ', wynik:0:2);</b> -&nbsp; tutaj po pierwsze pokaza³em jak wypisaæ jedn± procedur± dwa rózne typy danych (tekst i liczba), oddzielaj±c je przecinkiem. Poza tym po zmiennej wynik napisa³em :0:2. Oznacza to, ¿e u³amek ma napisaæ tylko do liczb setnych, natomiast sam± liczbê pisze tyle ile wymaga ta liczba. Mogli¶my te¿ daæ u³amek do wiêkszych liczb: wynik:0:10. Na tym skoñczymy typy rzeczywiste. Pójd¼my teraz do:<br> <br> <b>Typy logiczne</b><br> <br> Typy logiczne s± zmiennymi, które mog± przyj±c tylko dwie warto¶ci: True lub False. Prawdziwego zastosowania zmiennych logicznycxh nie mogê pokazaæ póki nie zapoznamy siê z warunkami i pêtlami. Dlatego do¶æ nietypowy przyk³ad:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> <br> var logik1, logik2: Boolean;<br> <br> begin<br> logik1 := True;<br> logik2 := not logik1;<br> writeln('Warto¶æ logik1: ', logik1);<br> writeln('Warto¶æ logik2: ', logik2);<br> readln;<br> end.</font><br> <br> <b>var logik1, logik2: Boolean;</b> - tutaj deklarujemy dwie zmienne (logik1, logik2) jako typ Boolean, to jest w³a¶nie typ zmiennej logicznej.<br> <br> <b>logik := True;</b> - tutaj pod zmienn± logik1 podstawiamy warto¶æ True.<br> <br> <b>logik2 := not logik1;</b> - tutaj natomiast podstawiamy odwrotn± warto¶æ dla zmiennej logik2 ni¿ ma logik1. W tym przypadku warto¶æ wyniesie False.<br> <br> Je¶li nie bardzo zrozumieli¶cie typ logiczny to siê nie martwcie. Poka¿ê jego dzia³anie przy pêtlach i warunkach, bo tam jest naju¿yteczniejszy.<br> <br> <b>Zmienne ³añcuchowe</b><br> <br> Zmienne ³añcuchowe to nic innego jak zmienne, które mog± przechowywaæ dowolne znaki: liczby, litery i znaki typ !@#,.()?. Chyba wszystko jasne? No, wiêc na pocz±tek typy zmiennych ³añcuchowych.</p><div align=center><center><table border=1 width=100% bordercolor=#CBCDE2 cellspacing=0 cellpadding=2><tr><td width=37% class=9ptV align=center><b>Typ</b></td><td width=63% class=9ptV align=center><b>Maksymalna d³ugo¶æ</b></td></tr><tr><td width=37% class=9ptV align=center>ShortString</td><td width=63% class=9ptV align=center>255</td></tr><tr><td width=37% class=9ptV align=center>AnsiString</td><td width=63% class=9ptV align=center>~3 GB</td></tr><tr><td width=37% class=9ptV align=center>String</td><td width=63% class=9ptV align=center>255 lub ~3 GB&nbsp;</td></tr><tr><td width=37% class=9ptV align=center>WideString</td><td width=63% class=9ptV align=center>~1.5 GB&nbsp;</td></tr></table></center></div><p class=9ptV align=justify>Jak widzicie jest trochê tych typów. Odradzam korzystanie z ShortString (jest to string z poprzednich wersji Delphi), a najczê¶ciej u¿ywanym jest String. Domy¶lnie w Delphi jest w³±czana dyrektywa kompilatora {$H+}, która powoduje, ¿e String jest d³ugo¶ci ~3 GB. Natomiast, gdy w programie damy {$H-}, to przyjmie d³ugo¶æ maksymaln± 255. Reszta typów jest praktycznie w ogóle nie stosowana, co nie oznacza, s± z³e. Ma³y przyk³adzik:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var s1, s2, s3:String;<br> <br> begin<br> s1 := 'Hello';<br> s2 := 'World!';<br> writeln('Dwie zmienne');<br> writeln(s1 + ' ' + s2);<br> s3 := s1 + ' ' + s2;<br> writeln('Jedna zmienna');<br> writeln(s3);<br> readln;<br> end.</font><br> <br> <b>s1 := 'Hello';</b> - tutaj podstawi³em pod zmienn± s1 tekst Hello. Oczywi¶cie piszemy w apostrofach.<br> <br> <b>writeln(s1+' ' +s2);</b> - tutaj wypisa³em dwie zmienne (s1 i s2)oddzielone spacj±.<br> <br> <b>s3:=s1+' '+s2;</b> - tutaj natomiast pod zmienn± s3 podstawi³em warto¶æ zmiennej s1, spacjê i warto¶æ s2. Dziêki temu warto¶æ s3 wyniesie: Hello World!<br> <br> Powy¿szy program pokazuje bardzo proste zastosowanie (je¶li mo¿na to tak nazwaæ) Stringów. Poni¿ej co¶ ciekawszego:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var imie, nazwisko:String;<br> <br> begin<br> writeln('Jakie masz imiê?');<br> readln(imie);<br> writeln('Jakie masz nazwisko?');<br> readln(nazwisko);<br> writeln('Kto¶ mi powiedzia³, ¿e nazywasz siê ' + imie + ' ' + nazwisko + '. Ciekawe kto to by³?');<br> readln;<br> end.</font><br> <br> <b>readln(imie);</b> - w podstawowym Object Pascalu tak bêdziemy wyci±gaæ zmienne od u¿ytkownika. Przy prawdziwym Delphi bêdzie trochê inaczej. Tutaj wczytujemy warto¶æ zmiennej imie.<br> <br> Reszta to pryszcz. Zapewne jeszcze nie wiecie, ¿e mo¿na z przyczyn technicznych :) ustaliæ maksymaln± d³ugo¶æ Stringa. Otó¿ robimy to tak:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var imie:String[3];<br> <br> begin<br> writeln('Jakie masz imiê?');<br> readln(imie);<br> writeln('Nazywasz siê ' + imie + '? Tak brzydko?');<br> readln;<br> end.</font><br> <br> <b>var imie: String[4];</b> - tutaj ustalili¶my, ¿e maksymaln± d³ugo¶ci± Stringa imie bedzie 3. Zapewne zauwa¿yli¶cie, ¿e program wy¶wietli³ tylko czê¶æ waszego imienia (no, chyba, ¿e kto¶ ma imiê na 3 litery:)), to jest w³a¶nie skutek naszego dzie³a przy deklaracji. Spróbujcie po procedurze readln(imie); wstawiæ tak± oto linijkê: SetLength(imie, 15); I co wy¶wietli³o ca³a nazwê? To jest w³a¶nie procedura do ustalania d³ugo¶ci stringa.<br> <br> By³bym zapomnia³ oto typowe warto¶ci stringów:<br> tekst := ' '; spacja<br> tekst := ''; pusty string (0 znaków)<br> <br> Wiecie co? Przerazi³em siê trochê, gdy zobaczy³em wielko¶æ tego pliku. Tak, pierwsza lekcja a ju¿ zajmuje ponad 20 KB. Dlatego, ¿eby was ju¿ nie zniechêcaæ skoñczê dzisiejsz± lekcjê. Istnieje jeszcze parê typów zmiennych, których nie opisa³em, ale bêd± nam potrzebne pó¼niej i na pewno je opiszê. Je¶li macie jakie¶ pytania to walcie ¶mia³o, tylko proszê, ¿eby zaznaczyæ w mailu, ¿e chodzi o kurs Delphi (w MagaZinie of kors). Ufff... :)</p></center></center><div align=justify><p class=9ptV align=right><font color=#000000><b>PC3T</b><br> </font><a href=mailto:przempc@poczta.onet.pl class=link2><font color=#4048A8>przempc@poczta.onet.pl</font></a></div></td></tr></table></div></td></tr><tr><td width=100% height=20 valign=bottom><div align=center><table border=0 width=586 height=20 cellspacing=0 cellpadding=0><tr><td width=135 background=../img/line3.gif><p align=right><img border=0 src=../img/line.gif width=9 height=20></td><td width=310 valign=bottom><p align=center class=9ptV><a href=23.htm class=link2><font color=#4048A8>poprzednia strona</font></a><font color=#4048A8>:: </font><a href=spis.htm class=link2><font color=#4048A8>spis tre¶ci</font></a><font color=#4048A8>:: </font><a href=25.htm class=link2><font color=#4048A8>nastêpna strona</font></a></td><td width=135 background=../img/line3.gif><img border=0 src=../img/line2.gif width=9 height=20></td></tr></table></div></td></tr><tr><td width=100% height=20 valign=top>&nbsp;</td></tr><tr><td width=100% height=25 valign=middle bgcolor=#4048A8><div align=center><table border=0 width=583 cellspacing=0 cellpadding=0><center><td width=596 class=9ptV valign=bottom colspan=6><p class=9ptV align=center><font color=#FFFFFF><b>WSZELKIE PRAWA ZASTRZE¯ONE:: COPYRIGHT &copy; MAGAZIN 2001-2002</b></font></td></center><center></table></center></div></td></tr><tr><td width=100% height=20 valign=top>&nbsp;</td></tr></table></div></body></html>