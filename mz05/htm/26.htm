<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<link rel="stylesheet" href="magazin.css" TYPE="text/css">
<title>MagaZin #5 :: listopad 2001</title>
</head>

<body link="478DE7" vlink="478DE7" alink="478DE7" topmargin="0" bottommargin="0" bgcolor="#000000">
<div align="center">
  <center>
  <table border="0" width="700" cellspacing="0" cellpadding="0" height="1" bgcolor="#FFFFFF">
    <tr>
      <td width="697" height="154" valign="top"><img border="0" src="../img/up.png" width="700" height="150"></td>
    </tr>
  </center>
    <tr>
      <td width="697" height="1" valign="top">
        <table border="0" width="700" cellspacing="0" cellpadding="0" height="1" bgcolor="#FFFFFF">
          <tr>
            <center>
            <td width="697" height="1" valign="top"></center>
            <div align="center">
              <center>
              <table border="0" width="92%" cellspacing="0" cellpadding="4">
                <tr>
                  <td width="10%" valign="middle"><a href="25.htm"><img border="0" src="../img/4.gif" align="right" width="50" height="25"></a></td>
                  <td width="23%" valign="middle"><font face="Arial" size="1">poprzednia</font></td>
                  <td width="33%" valign="middle">
                    <p align="center"><a href="spis.htm"><img border="0" src="../img/6.gif" width="200" height="20"></a></td>
                  <td width="23%" valign="middle">
                    <p align="right"><font size="1" face="Arial">nastêpna</font></td>
                  <td width="10%" valign="middle"><a href="27.htm" class="link2"><img border="0" src="../img/3.gif" width="50" height="25"></a></td>
                </tr>
              </table>
              </center>
            </div>
            </td>
          </tr>
        </table>
    </td>
    </tr>
  <center>
    <tr>
      <td width="697" height="83" valign="top">
        <div align="center">
          <center>
          <table border="0" width="92%" height="1" cellspacing="10" cellpadding="2">
            <tr>
              <td width="100%" height="5" valign="top" colspan="2"></td>
            </tr>
            <tr>
              <td width="100%" height="16" valign="top" bgcolor="#000000" colspan="2"><img border="0" src="../img/13a.gif" width="225" height="14"></td>
            </tr>
            <tr>
              <td width="100%" height="1" valign="top" colspan="2"><font face="Arial" size="2"><br>
                </font>
                <div align="center">
                  <center>
                  <table border="0" width="100%" cellspacing="0" cellpadding="0">
                    <tr>
                      <td width="64%" valign="top" height="30"><font class="u">Linux:
                        Bash, czyli standardowy shell, cz. 2</font>
                      </td>
                    </center>
          </center>
  </center>
                  <td width="36%" valign="top" height="30">
                    <p align="right"></td>
                </tr>
              </table>
            </div>
  <center>
          <center>
          </center></center>
    </td>
            </tr>
            <tr>
              <td width="50%" height="112" valign="top">
            <p align="justify"><font class="9pt"><b>Klocki w k±t</b><br>
                <br>
                W tym artykule zajmiemy siê ju¿ PRAWDZIWYM PROGRAMOWANIEM. Bash oprócz funkcji interaktywnego shella jest równie¿ ca³kiem potê¿nym jêzykiem programowania, w którym pisaæ mo¿emy w³asne skrypty. Tak jak ka¿dy szanuj±cy siê jêzyk programowania, bash udostêpnia zmienne, pêtle i instrukcje warunkowe.<br>
                <br>
                <b>Struktura skryptu</b><br>
                <br>
                Skrypt jest po prostu plikiem tekstowym, w którym zapisano kolejne instrukcje. Plikowi temu nadajemy prawo wykonywania (chmod +x nazwa_pliku) i voila! Mamy skrypt. Domy¶lnie wykona siê on pod kontrol± shella zdefiniowanego jako domy¶lny (w pliku /etc/passwd) dla u¿ytkownika. Dla bezpieczeñstwa mo¿emy zadeklarowaæ, jaki program ma pe³niæ rolê interpretera naszego skryptu. W tym celu pierwsza linia musi mieæ postaæ&nbsp;<br>
                <br>
                <font class=9ptv><font color="#478DE7">#!/¶cie¿ka/do/programu</font><br>
                <br><font class="9pt">
                np.<br>
                <br><font class=9ptv>
                <font color="#478DE7">#!/bin/bash</font><br>
                <br><font class=9pt>
                Znak # we wszystkich jêzykach skryptowych oznacza pocz±tek komentarza rozci±gaj±cego siê a¿ do koñca linii. Wszystkie inne linie interpretowane s± jako polecenia.<br>
                <br>
                <b>Zmienne</b><br>
                <br>
                Zmienne s± to¿same ze zmiennymi ¶rodowiskowymi. Przypisanie dowolnego ci±gu znaków do zmiennej realizowane jest poprzez operator =, np.<br>
                <br>
                <font class=9ptv>
                <font color="#478DE7">
                [mac@localhost art3]$ pliki=`ls`<br>
                [mac@localhost art3]$ echo $pliki linux.html<br>
                [mac@localhost art3]$ _</font><br>
                <br>
                <font class=9pt>
                Widzimy te¿ sposób odwo³ania siê do zmiennej (komenda echo wypisuje na stdout swoje parametry). $nazwa_zmiennej rozwijana jest przez bash do jej zawarto¶ci. Tak zdefiniowane zmienne nie s± jednak przekazywane do programów (czy innych skryptów) wywo³ywanych z wnêtrza bie¿±cego. Gdy chcemy aby by³y widoczne (np. ustawiamy zmienn± $PATH), nale¿y u¿yæ s³owa kluczowego export. Przyk³adowo export PATH=.:$PATH dodaje katalog bie¿±cy na pocz±tku ¶cie¿ki przeszukiwania. Mo¿na te¿
                &quot;wyeksportowaæ'' ju¿ istniej±c± zmienn± poprzez wywo³anie export nazwa_zmiennej. Np. w poprzednim przyk³adzie napisanie w linii komend polecenia export pliki spowoduje, ¿e zmienna pliki bêdzie widoczna we wszystkich nastêpnie uruchamianych programach, a¿ do wykonania polecenia unset pliki. Polecenie to usuwa zmienn± ze ¶rodowiska.<br>
                <br>
                <b>Pêtle</b><br>
                <br>
                Najczê¶ciej wykorzystywan± pêtl± programow± basha jest pêtla for. Umo¿liwia ona wykonanie kawa³ka kodu nadaj±c pewnej zmiennej kolejne warto¶ci z listy. Na przyk³ad (uwaga, jest to tzw. jednolinijkowiec czyli skrypt, który mo¿na w ca³o¶ci zmie¶ciæ w linii komend:&nbsp;<br>
                <br>
                <font class=9ptv>
                <font color="#478DE7">
                
                [mac@localhost art3]$ for i in 1 2 3; do echo Liczba $i; done<br>
                Liczba 1<br>
                Liczba 2<br>
                Liczba 3<br>
                [mac@localhost art3]$ _</font><br>
                <br>
                <font class=9pt>
                Wywo³anie, to jak widaæ for zmienna in lista; do komendy; done. Komendy rozdzielamy ¶rednikami lub znakami nowej linii (jest to to¿same). Lista mo¿e sk³adaæ siê z elementów rozdzielonych spacjami, tabulatorami lub znakami nowej linii.&nbsp;
                </font>
                
              <td width="50%" height="93" valign="top">
                <p align="justify"><font class="9pt"> Oczywi¶cie listy nie trzeba wypisywaæ rêcznie, mo¿e ni± byæ wszystko, co w shellu rozwinie siê do odpowiedniej formy. Prawid³owe s± zatem konstrukcje: for plik in *.mp3; do mpg123 $plik; done , for wyr in `cat plik.txt` do echo $wyr; done | sort wypisuj±ca wszystkie wyrazy z pliku tekstowego w kolejno¶ci alfabetycznej itd.&nbsp;<br>
                Pêtle until i while maj± bardzo podobn± sk³adniê. Wywo³uje siê je nastêpuj±co: until test; do komendy; done oraz while test; do komendy; done. Test jest normaln± komend±, która jak wiemy, mo¿e zakoñczyæ siê sukcesem lub pora¿k± (bardziej dok³adnie - zwróciæ zero lub inn± warto¶æ jako stan wyj¶cia). until wykonuje siê a¿ test zwróci zero (sukces), while - a¿ test zakoñczy siê pora¿k±. Testem mo¿e byæ dowolny program, gdy¿ ka¿dy zwraca przy zakoñczeniu jak±¶ warto¶æ. Najbardziej u¿yteczny jest jednak program test lub jego wbudowana w basha forma - o tym za chwilê.<br>
                <br>
                <b>Instrukcja warunkowa</b><br>
                <br>
                if test1; then komendy1; elif test2; then komendy2; elif test3; then komendy3; ... else komendyN; fi. Wykona komendy1 w razie sukcesu polecenia test1, komendy2 w razie sukcesu test2 itd. KomendyN wykonaj± siê o ile ¿aden z testów nie zakoñczy³ siê sukcesem. Bloki elif oraz else s± opcjonalne. Pro¶ciutkie przyk³ady podam w nastêpnym podrozdziale.<br>
                <br>
                <b>
                Wbudowane testy</b><br>
                <br>
                Bash umo¿liwia przeprowadzanie prostych testów w instrukcjach if, while i until bez potrzeby wywo³ywania zewnêtrznych programów. Jest to w zasadzie wbudowana wersja polecenia test (man test). Wywo³uje siê j± po prostu w nawiasach kwadratowych, np. [ -z $zmienna ] sprawdza, czy zmienna rozwija siê w pusty ci±g (czyli nie jest zdefiniowana); [ -f /jakis/plik ] sprawdza istnienie pliku itd. Zwróæ uwagê na spacje oddzielaj±ce nawiasy od zawarto¶ci. Pe³n± listê obs³ugiwanych parametrów znajdziesz w manualu do polecenia test. Stamt±d dowiesz siê te¿ jak ³±czyæ warunki operatorami ,,oraz'' i
                ,,&quot;ub''. Ma³y przyk³adzik:&nbsp;<br>
                - if [ -n $DISPLAY ]; then gvim; else vi; fi uruchamia okienkow± lub konsolow± wersjê edytora vi w zale¿no¶ci od tego, czy jeste¶my w sesji X Window czy na konsoli tekstowej (sprawdza ustawienie zmiennej DISPLAY).&nbsp;<br>
                - if [ -f /var/log/messages -o -d /etc ]; then echo jest; fi Wypisuje
                ,&quot;jest'' o ile w systemie znajduje siê plik /var/log/messages lub katalog /etc.<br>
                <br>
                <b>
                Minikalkulator</b><br>
                <br>
                Bash mo¿e te¿ dokonywaæ samodzielnie prostych rachunków. Napis $[ dzia³anie ] rozwija siê w jego wynik. Przyk³adowo: echo $[ 2*2 ] wypisze 4. Oczywi¶cie operandami mog± byæ zmienne lub wszystko, co rozwinie siê w liczbê ca³kowit± (albo w dzia³anie). Bash rozpoznaje m.in. operatory:<br>
                <br>
                - + - dodawania<br>
                - - - odejmowania<br>
                - * - mno¿enia<br>
                - / - dzielenia<br>
                - % - reszty z dzielenia<br>
                - ** - potêgowania<br>
                <br>
                Oraz operatory logiczne i bitowe. Pe³na lista w manualu pinfo bash (Bash Features->Shell Arithmetic).<br>
                <br>
                <b>
                Koniec?</b><br>
                <br>
                Z pewno¶ci± nie. Przedstawione w niniejszym artykule zagadnienia to dopiero wierzcho³ek góry lodowej. Bash to program o ogromnym stopniu komplikacji i niesamowitych mo¿liwo¶ciach. Bardziej dociekliwych zachêcam do samodzielnych eksperymentów wspomaganych hipertekstowym manualem (p)info bash lub stron± manuala man bash.<br>
                <br>
                </font>
                
            </tr>
            <tr>
              <td width="100%" height="1" valign="top" colspan="2">
              <p align="right"><font class="9pt">Oprac. <b>Loopus</b> na
              podstawie artyku³u znalezionego w Sieci<a href="mailto:lupusfm@poczta.onet.pl&nbsp;" class="link"><br>
              lupusfm@poczta.onet.pl</a><br>

              </font>

            </tr>
            <tr>
            <td width="100%" height="1" valign="middle" colspan="2" bgcolor="#000000"><b><font face="Verdana" color="#FFFFFF" size="1">&nbsp;Copyright
              &copy; MagaZin 2001</font></b></td>
            </tr>
  </table>
          <table border="0" width="92%" height="1" cellspacing="10" cellpadding="2">
  <center>
  </table>
        </div>
          </center>
      </td>
    </tr>
  </table>
</div>

</body>

</html>
