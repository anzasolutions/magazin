<html><head><meta http-equiv=Content-Type content="text/html; charset=iso-8859-2"><link rel=stylesheet href=magazin.css TYPE=text/css><title>MagaZin #11 :: czerwiec/lipiec 2002</title></head><body link=#478DE7 vlink=#478DE7 alink=#478DE7 topmargin=0 bottommargin=0 bgcolor=#000000><div align=center><center><table border=0 width=650 style="border-style: solid; border-width: 0" cellspacing=0 cellpadding=0 height=100% bgcolor=#FFFFFF><tr><td width=100% height=20 valign=top></td></tr></center><tr><td width=100% height=25 valign=middle bgcolor=#4048A8><div align=center><table border=0 width=583 cellspacing=0 cellpadding=0><center><td width=400 class=9ptV valign=bottom colspan=3><p class=9ptV><font color=#FFFFFF><b>MAGAZIN #11 :: STRONA 17</b></font></td></center><td width=133 class=9ptV valign=bottom><p align=right><font color=#FFFFFF><img border=0 src=../img/direct.gif width=7 height=10><img border=0 src=../img/direct3.gif width=7 height=10><img border=0 src=../img/direct2.gif width=7 height=10></font></td><center><td width=8 class=9ptV valign=bottom></td><td width=55 class=9ptV><b><font color=#FFFFFF>KOMPUTER</font></b></td></table></center></div></td></tr><center><tr><td width=100% height=5 valign=top><p class=9ptV>&nbsp;</td></tr><tr><td width=100% height=20 valign=bottom></center><div align=center><table border=0 width=586 height=20 cellspacing=0 cellpadding=0><tr><td width=135 background=../img/line3.gif><p align=right><img border=0 src=../img/line.gif width=9 height=20></td><center><td width=310 valign=bottom><p align=center class=9ptV><a href=16.htm class=link2><font color=#4048A8>poprzednia strona</font></a><font color=#4048A8> :: </font><a href=spis.htm class=link2><font color=#4048A8>spis tre¶ci</font></a><font color=#4048A8> :: </font><a href=18.htm class=link2><font color=#4048A8>nastêpna strona</font></a></td><td width=135 background=../img/line3.gif><img border=0 src=../img/line2.gif width=9 height=20></td></tr></table></center></div></td></tr><center><tr><td width=100% height=5 valign=top><p class=9ptV>&nbsp;</td></tr><tr><td width=100% height=21 valign=top><div align=center><center><table border=0 width=600 cellspacing=0 cellpadding=6 height=20 bgcolor=#FFFFFF><tr><td width=285 height=20 valign=top class=9pt><div align=center><center><table border=0 width=100% cellspacing=0 cellpadding=0><tr><td width=100% valign=top class=9ptV height=15><i>Software</i></td></tr><tr><td width=100%><p class=u>Kurs Delphi #2</td></tr></table></center></div><p class=9ptV align=justify><b>Object Pascal</b><br> <br> Witam w drugiej czê¶ci kursu Delphi, a na razie Object Pascala. Dzisiaj (no, mo¿e w tym odcinku, bo nie wiem kiedy bêdziecie czytaæ ten odcinek :)) omówiê warunki, pêtle oraz funkcje i procedury co umo¿liwi nam od nastêpnego odcinku zaj±æ siê prawdziwym Delphi (yeah!). Zanim zaczniemy t± czê¶æ, przypominam, ¿e aby podane poni¿ej programy dzia³a³y to trzeba: w³±czyæ Delphi, pó¼niej menu Project -> Options, a na karcie Linker zaznaczcie Generate Console Application. Zamknijcie Options, zamknijcie okno Form1 i okno Unit1.pas (nie zapisujcie zmian), a w menu w³±czcie Options -> View Source.<br> <br> <b>Warunki</b><br> <br> Zanim zajmiemy siê warunkami, muszê wam pokazaæ operatory relacji, które s³u¿± do porównywania dwóch warto¶ci. jak siê domy¶lacie warunki maj± mniej wiêcej tak± budowê: (mówi±c po polskiemu) je¶li "co¶" spe³nia warunek z "czym¶" to zrób to, a je¿eli nie to zrób to. Ale dosyæ gadania pora na tabelkê:</p><div align=center><table border=1 width=100% cellspacing=0 cellpadding=4 bordercolor=#C0C0C0><tr><td width=50% class=9ptV><p align=center><b>Operator</b></td><td width=50% class=9ptV><p align=center><b>Relacja&nbsp;</b></td></tr><tr><td width=50% class=9ptV valign=top><p align=center>=<br> &lt;><br> &lt;<br> ><br> &lt;=<br> >=<br> in</td><td width=50% class=9ptV valign=top><p align=center>równy<br> nierówny<br> mniejszy<br> wiêkszy<br> mniejszy lub równy<br> wiêkszy lub równy<br> w przedziale</td></tr></table></div><p class=9ptV align=justify><b>if... then<br> </b><br> Budowa tego warunku jest taka: if wyra¿enie then instrukcja. Zreszt± przyk³adzik:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var lata:byte;<br> <br> begin<br> writeln('Ile masz lat?');<br> readln(lata);<br> if lata>50 then writeln('Masz za sob± du¿o ¿ycia');<br> readln;<br> end.</font><br> <br> if lata>50 then writeln('...') - tutaj da³em warunek, ¿e je¶li kto¶ bêdzie mia³ powy¿ej 50 lat wtedy wy¶wietli mu siê tekst: Masz za sob± du¿o ¿ycia.<br> <br> Ten program ma ma³e zastosowanie, bo gdy kto¶ na pisze poni¿ej 50 lat wtedy nic mu siê nie wy¶wietli. Dlatego mo¿emy daæ jeszcze else:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var lata:byte;<br> <br> begin<br> writeln('Ile masz lat?');<br> readln(lata);<br> if lata>50 then writeln('Masz za sob± du¿o ¿ycia')<br> else writeln('Jeste¶ jeszcze m³ody');<br> readln;<br> end.</font><br> <br> if lata>50 then writeln('...') else writeln('...'); - tutaj doda³em do warunku (je¶li ma wiêcej ni¿ 50 lat) wyraz inaczej (w innym przypadku) mówi±cy, ¿e instrukcja po nim ma zostaæ wykonana, gdy warunek siê nie spe³ni. Acha zwróæcie na brak ¶rednika po procedurze writeln('Masz za sob± du¿o ¿ycia') nigdy siê nie stawia ¶rednika przed wyrazem else (nawet w poprzedniej linijce).<br> <br> No dobra program teraz wygl±da trochê lepiej, ale to jeszcze nie to, bo chyba nie powiemy nikomu, ¿e maj±c 40 lat jest m³ody. :) Mo¿na daæ przecie¿ wiêcej warunków, a co?<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var lata:byte;<br> <br> begin<br> writeln('Ile masz lat?');<br> readln(lata);<br> if lata in [50..100] then<br> writeln('Masz za sob± du¿o ¿ycia');<br> if lata in [30..49] then<br> writeln('M³ody to ty nie jeste¶');<br> if lata in [15..29] then<br> writeln('M³ody jeste¶');<br> if lata in [9..14] then<br> writeln('Ledwo odros³e¶ od ziemi');<br> if lata in [5..8] then<br> writeln('Ju¿ interesuje Ciebie komputer?');<br> if lata in [0..4] then<br> writeln('Kto Ci to czyta?');<br> readln;<br> end.</font><br> <br> Jak widzicie zastosowa³em tutaj wyra¿enie in [x..y], które sprawdza czy dana liczba jest w danym przedziale. Program bêdzie dzia³a³ póki kto¶ nie wpisze powy¿ej 100 lat, a dlaczego? Zobaczcie, ¿e nigdzie nie da³em przedzia³u liczb powy¿ej stu. Aby program dzia³a³ poprawnie dodajmy linijkê:<br> if lata>100 then writeln('Gratulujê wieku!');<br> Mo¿na te¿ daæ warunki, które wymagaj± dok³adniejszych warto¶ci:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var palce:byte;<br> <br> begin<br> writeln('Ile masz palców w rêkach');<br> readln(palce);<br> if palce=10 then<br> writeln('Nie stwierdzono braku jakiego¶ palca');<br> if palce&lt;>10 then<br> writeln('Co¶ nie gra z tymi palcami albo ty ¼le liczysz');<br> readln;<br> end.<br> <br> if palce=10 then {...} je¶li zmienna palce ma warto¶æ równ± 10 wtedy {...}<br> if palce &lt;>10 then {...} je¶li warto¶æ zmiennej palce jest ró¿na od 10 wtedy {...}</font><br> <br> Poni¿ej warunki na zmiennych typu string oraz co¶ ekstra:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var plec:string;<br> <br> begin<br> writeln('Jakiej jeste¶ p³ci? m/k');<br> readln(plec);<br> write('Twoja p³eæ: ');<br> if plec = 'm' then<br> writeln('mê¿czyzna');<br> if plec = 'k' then<br> writeln('kobieta');<br> if (plec&lt;>'m') and (plec&lt;>'k') then<br> writeln('UFO');<br> readln;<br> end.</font><br> <br> if plec='m' then {...} tak jak mówi³em warto¶ci typu string podstawiamy oraz porównujemy w apostofach.<br> if (plec&lt;>'m') and (plec&lt;>'k') then {...} tutaj jest ten bonus ode mnie. :) Je¶li warto¶æ zmiennej nie jest równa, ani 'm', ani 'k' wtedy program wypisze nam 'UFO'. :) Je¶li w jednym warunku porównujemy wiêcej wyra¿eñ to te wyra¿enia wpisujemy w nawiasy. Dla bezpieczeñstwa mogli¶my jeszcze zrobiæ tak:<br> <br> <font color=#4048A8>if (plec = 'm') or (plec='c') then<br> writeln('mê¿czyzna');<br> if (plec = 'k') or (plec='d') then<br> writeln('kobieta');<br> if (plec&lt;>'m') and (plec&lt;>'k') and (plec&lt;>'d') and (plec&lt;>'c') then<br> writeln('UFO');<br> <br> if (plec='m') or (plec='c') then {...} je¶li zmienna plec ma warto¶æ 'm' lub 'c'<br> if (plec&lt;>'m') and (plec&lt;>'k') and (plec&lt;>'d') and (plec&lt;>'c') then {...} je¶li warto¶æ zmiennej plec nie jest równa 'm', 'k', 'd' ani 'c'</font><br> <br> Zauwa¿yli¶cie na pewno doj¶cie dwóch operatorów or i and. Zapewniam was, ¿e to nie s± jedyne operatory tego typu. Tabela poni¿ej:</p><div align=justify><table border=1 width=100% cellspacing=0 cellpadding=4 bordercolor=#C0C0C0><tr><td width=50% valign=top align=center class=9ptV><b>Operator</b></td><td width=50% valign=top align=center class=9ptV><b>Operacja&nbsp;</b></td></tr><tr><td width=50% valign=top align=center class=9ptV>not<br> and<br> or<br> xor</td><td width=50% valign=top align=center class=9ptV>negacja<br> koniunkacja<br> alternatywa<br> ró¿nica symetryczna</td></tr></table></div><p class=9ptV align=justify>Operatory or i and pokaza³em powy¿ej. Teraz poka¿ê operator not:<br> <br> <font color=#4048A8>if not plec='m' then writeln('Kobieta');</font><br> <br> Natomiast operator xor ma trochê dziwne zastosowanie: warunek spe³ni siê gdy jedno z wyra¿eñ bêdzie prawdziwe, a drugie fa³szywe. Do tego pos³u¿y nam w ogóle inny program:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var liczba,liczba2:Integer;<br> <br> begin<br> writeln('Podaj liczbê');<br> readln(liczba);<br> writeln('Podaj drug± liczbê');<br> readln(liczba2);<br> if (liczba=5) xor (liczba2=5) then<br> writeln('Jedna z liczb jest równa 5, a druga nie');<br> readln;<br> end.</font><br> <br> Prawdziwego zastosowania tego operatora nie znalaz³em i przyznam, ¿e spotka³em siê z nim co dopiero podczas pisania tego kursu.<br> <br> <b>case... of</b><br> <br> Ten warunek jest bardziej zwi±zany ze zmiennymi ni¿ poprzedni. On wykonuje dan± instrukcjê, gdy dana zmienna osi±gnie dan± warto¶æ. Budowa jest taka: w przypadku zmiennej zrób: gdy warto¶æ1, gdy warto¶æ2 itd. Dobra pora na programik:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var znak:char;<br> <br> begin<br> writeln('Podaj znak');<br> readln(znak);<br> case znak of<br> 'a': writeln('Nacisnê³e¶ "a"');<br> 'z': writeln('Nacisnê³e¶ "z"');<br> end;<br> readln;<br> end.</font><br> <br> var znak: char; - tutaj zdefiniowa³em now± dla was zmienn±, o której wspomina³em. Jej inno¶æ od Stringa polega na tym, ¿e mo¿e przyj±æ ³añcuch (tekst) maksymalnej d³ugo¶ci 1 (jeden). Wykorzystuje te¿ kod ASCII, który umo¿liwia wstawienie znaku (np: #33), umo¿liwia te¿ sprawdzenie czy dany znak to spacja, kursor w górê, dó³ itp itd.<br> case znak of - tutaj zaczêli¶my warunek case... of. Pomiêdzy wyrazami case a of wstawiamy nazwê zmiennej, której warto¶ci bêdziemy sprawdzaæ.<br> 'a': writeln('Nacisnê³e¶ "a"'); - tutaj instrukcja zostaje wykonana, gdy znak bêdzie równy 'a'<br> <br> Jeszcze jeden przyk³ad:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var liczba:byte;<br> <br> begin<br> writeln('Podaj liczbê');<br> readln(liczba);<br> case liczba of<br> 1,2,3: writeln('Nacisnê³e¶ "1, 2 lub 3"');<br> 4..10: writeln('Nacisnê³e¶ "4-10"');<br> end;<br> readln;<br> end.<br> </font><br> Jak zawsze przypomnienie: nie stosujemy apostrofów w liczbach. Zastosowa³em tutaj przedzia³y oraz wiêcej zmiennych przy jednej instrukcji. Wiêcej przyk³adów nie bêdê dawa³. Pomêczcie siê sami. :) Jeszcze tylko jedna uwaga: je¶li chcecie, ¿eby po warunku zosta³o wykonanych wiêcej instrukcji musicie daæ s³owa begin {instrukcje} end; Zreszt± zobaczcie:<br> <br> <font color=#4048A8>if liczba='10' then<br> begin<br> writeln('Wybra³e¶ 10');<br> writelon('Zrobisz to jeszcze raz?');<br> end;<br> <br> To samo siê tyczy case of:<br> <br> case znak of<br> 'q':begin<br> writeln('q');<br> writeln('???');<br> end;<br> 'k': begin<br> writeln('k');<br> writeln('???');<br> end;<br> end;</font><br> <br> <b>Pêtle</b><br> <br> Pêtle moj± wiele zastosowañ od wypisania 10000 razy jakiego¶ zdania, poprzez wypisywanie liczb od 0 do 2000, do wykonywania danej instrukcji a¿ do momentu spe³nienia warunku. S± praktycznie podstaw± programowania.<br> <br> <b>repeat... until</b><br> <br> Ta pêtla ma proste dzia³anie: wykonuje dan± instrukcjê (miêdzy s³owem repeat a until) a¿ do spe³nienia warunku (po s³owie until). Wyra¿enia w pêtlach s± takie same jak w warunkach. Zobaczmy poni¿ej:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var znak:char;<br> <br> begin<br> repeat<br> writeln('Podaj instrukcjê q=koniec');<br> readln(znak);<br> until znak='q';<br> end.</font><br> <br> Program bêdzie wy¶wietla³ tekst: podaj instrukcjê q=koniec, a¿ do momentu wci¶niêcia "q".<br> repeat - tutaj zacz±³em pêtlê. Program bêdzie wykonywa³ instrukcjê, póki dotrze do s³owa until, wtedy sprawdzi jego wyra¿enie (znak='q') i albo zacznie pêtlê od nowa (je¶li warunek siê nie spe³ni) albo skoñczy pêtlê (warunek spe³ni³ siê).<br> until znak='q'; - tutaj po s³owie until poda³em warunek: zmienna znak musi przyj±æ warto¶æ "q" aby pêtla siê zakoñczy³a. Mogli¶my daæ wiêcej warunków:<br> until (znak='q') or (znak='e') or (znak='k');<br> <br> Rozumiem, ¿e zrozumieli¶cie, ale dla bezpieczeñstwa jeszcze jeden program:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var ins:byte;<br> <br> begin<br> repeat<br> writeln;<br> writeln('Wybierz instrukcjê');<br> writeln('1. Jeszcze raz');<br> writeln('2. Koniec');<br> write('Twój wybór: ');<br> readln(ins);<br> until ins=2;<br> end.</font><br> <br> <b>while... do</b><br> <br> Ta pêtla jest trochê inna, gdy¿ ona sprawdza warunek przed wykonaniem instrukcji: dopóki wyra¿enie rób instrukcjê. Wiêc looknijcie, tylko siê nie zapêtlijcie:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var znak:char;<br> <br> begin<br> while znak&lt;>'q' do<br> begin<br> writeln('Podaj wybór q=koniec');<br> readln(znak);<br> end;<br> end.</font><br> <br> Program bêdzie wypisywa³ pro¶bê o instrukcjê dopóki znak bêdzie mia³ warto¶æ inn± ni¿ "q".<br> while znak&lt;>'q' do {...} - tutaj da³em warunek powtarzania pêtli: dopóki znak jest równy "q".<br> Jak zauwa¿yli¶cie da³em po pêtli s³owa begin {...} end; jest to konieczne, gdy¿ pêtla while nie ma koñca w kodzie. Bez begin wykonywa³a by tylko pierwszy cz³on instrukcji: writeln('Podaj wybór q=koniec'); przez co pêtla nie mia³a by koñca.<br> <br> <b>for... do</b><br> <br> Ta pêtla jest trochê inniejsza :) od innych. Tutaj musimy ustaliæ ile razy instrukcja zostanie wykonana. Przydatne jest to w wielu rzeczach, np.: wypisanie wszystkich liczb od 1 do 100:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms, Windows;<br> var i:byte;<br> <br> begin<br> writeln('A teraz wszystkie liczby od 1 do 100:');<br> for i:= 1 to 100 do<br> begin<br> writeln(i);<br> sleep(50);<br> end;<br> readln;<br> end.</font><br> <br> uses Forms, Windows; - tutaj doda³em nowy modu³, ¿eby móc u¿yæ procedury sleep.<br> for i:= 1 to 100 do {...} - tutaj dla zmiennej i podstawia³em podczas dzia³ania pêtli zmienne od 1 do 100 oraz robi³em instrukcjê (writeln(i)), która wypisywa³a dan± warto¶æ zmiennej i.<br> sleep(50) - nowa procedura (sleep(dwMilliseconds: Cardinal)), która zatrzymuje dzia³alno¶æ programu na podan± ilo¶æ milisekund (tutaj 50=5 setnych).</td><td width=285 height=20 valign=top class=9pt></center></center><p class=9ptV align=justify>Przez ten czas program nic nie robi tylko czeka a¿ skoñczy siê podany czas. Dziêki czemu zobaczyli¶cie w miarê powolny wypis wszystkich liczb od 1 do 100. Acha procedura nale¿y do modu³u Windows, wiêc ¿eby jej u¿yæ musicie dodaæ do sekcji uses modu³ Windows.<br> <br> Pêtla for nie tylko wypisuje liczby od 1 do 100, mo¿emy wypisaæ wszystkie liczby od 0 do 100 (for zmienna:= 0 to 100 do {...}) oraz od 0 do 200000 (for liczba := 0 to 200000 do {...}). Acha pamiêtajcie tylko o zakresie zmiennych, nie mo¿ecie przecie¿ wymagaæ od byte, ¿eby policzy³o od 0 do 1000 (przedzia³ byte to: 0... 255). Gdy u¿yjecie Integer to wtedy mo¿ecie spokojnie u¿yæ liczb ujemnych (for cyfry:= -100 to 100 do {...}).<br> Pêtla for... do mo¿e te¿ odliczaæ, czyli liczyæ liczby, ale od koñca:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms, Windows;<br> var i:Integer;<br> <br> begin<br> writeln('A teraz wszystkie przeminione lata');<br> for i:= 2002 downto -1000 do<br> begin<br> writeln(i);<br> sleep(5);<br> end;<br> readln;<br> end.<br> </font><br> for i := 2002 downto -1000 do {...} - tutaj u¿ywaj±c s³owa downto, kaza³em programowi liczyæ liczby w dó³ tj, od 2002 do -1000, co znaczy, ¿e przy ka¿dym nastêpnym kroku pêtli warto¶æ zmiennej maleje o jeden.<br> <br> W ka¿dym z powy¿szych programów da³em liczenie liczb. A mo¿e by tak wypisaæ jakie¶ zdanie... powiedzmy 100 razy?<br> <br> <font color=#4048A8>program Project1;<br> uses Forms, Windows;<br> var i:Integer;<br> <br> begin<br> for i:= 1 to 100 do<br> begin<br> writeln('Matrix has you...');<br> sleep(100);<br> end;<br> readln;<br> end.</font><br> <br> Tutaj zmienna i pos³u¿y³a tylko programowi w celu prowadzenia pêtli. Jeszcze jeden przyk³ad, ale ciekawszy:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms, Windows;<br> var i:Integer;<br> <br> begin<br> write('LOADING');<br> for i:= 1 to 72 do<br> begin<br> write('.');<br> sleep(200);<br> end;<br> readln;<br> end.</font><br> <br> Ten program pisze 72 razy kropkê. A mo¿e co¶ bardziej skomplikowanego:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms, Windows;<br> var i:Integer;<br> <br> begin<br> write('LOADING');<br> for i:= 1 to 72 do<br> begin<br> write('.');<br> sleep(100 + i);<br> end;<br> readln;<br> end.</font><br> <br> Oprócz wy¶wietlenia 72 razy kropki, program zwiêksza odstêpy czasowe wraz z nastêpnym krokiem pêtli. Na samym koñcu program czeka a¿ 172 (100 + i, gdzie i= 72) milisekundy na zakoñczenie pêtli.<br> <br> <b>Problemy z pêtlami</b><br> <br> Poni¿sze dwie procedury s³u¿± do kontrolowania przebiegu pêtli. Czêsto siê zdarza, ¿e gdy u¿ytkownik zrobi co¶ czego nie przewidzieli¶my to ca³y program siê chrzani, mówi±c w miarê ³agodnie. Zazwyczaj takie programy od razu odpadaj± z ich listy programów u¿ywanych. Dlatego w Delphi jest mo¿liwo¶æ przerwania pêtli, gdy co¶ pójdzie nie tak. Takowych przyk³adów wam nie powiem, bo nie pamiêtam. Poka¿e natomiast jak bezpiecznie wyj¶æ z pêtli:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var znak:char;<br> <br> begin<br> repeat<br> writeln('Podaj znak: q-wyjscie; b-break:');<br> readln(znak);<br> if znak='b' then Break;<br> until znak='q';<br> if znak = 'q' then<br> writeln('Zakoñczono normlanie peltê')<br> else<br> writeln('Pêtla zosta³a zakoñczona przez Break');<br> readln;<br> end.</font><br> <br> Procedura Break po prostu niezw³ocznie koñczy pêtlê.<br> <br> Teraz nastêpna procedura:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var znak:char;<br> i:byte;<br> <br> begin<br> for i:= 0 to 10 do<br> begin<br> writeln('Podaj znak:');<br> readln(znak);<br> if znak='q' then Continue;<br> writeln('Pêtla wypisuje ten tekst, gdy nacisniesz znak ró¿ny od Q');<br> end;<br> readln;<br> end.</font><br> <br> Procedura Continue powoduje, ¿e wszystkie instrukcje zawarte po niej zostaj± opuszczone, a program przechodzi od razu do nastêpnego kroku pêtli.<br> <br> Takim oto sposobem zakoñczyli¶my pêtle. Teraz przejd¼my do procedur.<br> <br> <b>Procedury i funkcje</b><br> <br> Po pierwsze czym s± i do czego s³u¿±? Za³ó¿my, ¿e napisali¶my pewien ci±g instrukcji, które powtarzamy kilka razy w tym samym programie. Mo¿e zamiast ci±g³ego kopiowania tekstu kodu ¼ród³owego, zrobiæ to raz, a pó¼niej w skróconej formie kazaæ programowi wykonaæ te instrukcje kilka razy. Do tego s³u¿± procedury. Aby lepiej to wyja¶niæ zrobi³em program, który rysuje pole do gry kó³ko i krzy¿yk:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> <br> begin<br> writeln('-------');<br> writeln('| | | |');<br> writeln('-------');<br> writeln('| | | |');<br> writeln('-------');<br> writeln('| | | |');<br> writeln('-------');<br> readln;<br> end.</font><br> <br> Wiem trochê to prymitywne, ale nie taki jest g³ówny cel tego programu. Je¶li siê przyjrzycie to zauwa¿ycie, ¿e niektóre procedury siê powtarzaj± (4 razy writeln('-------'); i 3 razy writeln('| | | |');). Mo¿e by tak spróbowaæ wstawiæ je w procedury:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> <br> procedure poziome;<br> begin<br> writeln('-------');<br> end;<br> <br> procedure pionowe;<br> begin<br> writeln('| | | |');<br> end;<br> <br> begin<br> poziome;<br> pionowe;<br> poziome;<br> pionowe;<br> poziome;<br> pionowe;<br> poziome;<br> readln;<br> end</font><br> <br> Jak zauwa¿yli¶cie wstawi³em do programu dwie procedury: poziome i pionowe. Jedna rysuje linie poziome, a druga linie pionowe. Pó¼niej w g³ównej procedurze programu (miêdzy begin a end.) wstawi³em nazwy tych procedur kilka razy. Co zauwa¿yli¶cie? Efekt programu ten sam jak poprzednio, a lepiej to wygl±da. Teraz mówi±c ja¶niej: procedura jest to oddzielna czê¶æ kodu (instrukcji), któr± nazywamy odpowiednio (czyli jak chcemy), a pó¼niej mo¿emy w dowolnej ilo¶ci u¿yæ w dowolnym miejscu programu. Procedury zaczynamy i budujemy tak:<br> procedure {nazwa_procedury};<br> {var zmienne dowolnego typu}<br> begin<br> {instrukcje procedury}<br> end;<br> Zauwa¿cie, ¿e procedura zaczyna siê do begin, a koñczy na end; (ze ¶rednikiem, bez kropki!). W instrukcjach procedury mo¿emy dawaæ wszystko: pêtle, warunki, zmienne itp. Zobaczcie na ten programik:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms, Windows;<br> var koniec:Boolean;<br> <br> procedure liczby;<br> var i:Integer;<br> begin<br> for i:= 1 to 100 do<br> begin<br> write(i,' ');<br> sleep(50);<br> end;<br> readln;<br> end;<br> <br> procedure kalkulator;<br> var a,b:Integer;<br> begin<br> writeln;<br> writeln('Kalkulator');<br> write('Podaj a: ');<br> readln(a);<br> write('podaj b: ');<br> readln(b);<br> writeln('=',a+b);<br> readln;<br> end;<br> <br> procedure start;<br> var<br> wybor: byte;<br> begin<br> writeln('Witaj w programie!');<br> writeln('Co chcesz zrobiæ?');<br> writeln;<br> writeln('1. Liczby od 1 do 100');<br> writeln('2. Kalkulator dodawania');<br> writeln('3. Koniec');<br> writeln;<br> write('Twój wybór: ');<br> readln(wybor);<br> if wybor=1 then liczby;<br> if wybor=2 then kalkulator;<br> if wybor=3 then koniec:=true;<br> end;<br> <br> begin<br> koniec:=False;<br> repeat<br> start;<br> until koniec=true;<br> readln;<br> end.</font><br> <br> Jak widzicie program ci±gle wykonuje procedurê start, dopóki warto¶æ zmiennej koniec nie osi±gnie TRUE. W procedurze start mamy do wyboru: uruchomiæ procedurê liczby lub kalkulator albo zakoñczyæ program podstawiaj±c pod zmienn± koniec warto¶æ true .Na pewno zauwa¿yli¶cie, ¿e istnieje mo¿liwo¶æ odwo³ywania siê do procedur z innych procedur. Poza tym zademonstrowa³em pêtlê i warunki w procedurach oraz deklarowanie zmiennych. Tylko jeszcze kilka uwag: aby odwo³aæ siê z procedury do procedury, ta druga musi byæ napisana nad ni± (nie bezpo¶rednio nad). Inaczej program powie, ¿e nie wie co to jest. jeszcze o zmiennych, gdy deklarujemy zmienn± w g³ównym programie to wszystkie podprocedury widz± t± zmienn±, natomiast zmienne zadeklarowane tylko w procedurze, widzi tylko ta procedura.<br> <br> <b>Funkcje</b><br> <br> Funkcje maj± podobne zastosowanie do procedur, ale funkcja zawsze zwraca pewn± warto¶æ, któr± mo¿emy dowolnie wykorzystaæ. Czyli robi pewne instrukcje i daje nam wynik zwi±zany z tymi instrukcjami. Dla przyk³adu programik:<br> <br> <font color=#4048A8>program Project1;<br> uses Forms;<br> var liczba1, liczba2:Integer;<br> <br> function dodaj(a,b:Integer):Integer;<br> begin<br> Result:=a+b;<br> end;<br> <br> begin<br> write('Podaj a: ');<br> readln(liczba1);<br> write('Podaj b: ');<br> readln(liczba2);<br> writeln(liczba1,' + ',liczba2,' = ', dodaj(liczba1,liczba2));<br> readln;<br> end.</font><br> <br> function dodaj(a,b:Integer):Integer; - tutaj zdefiniowali¶my funkcjê dodaj o budowie dodaj(a:Integer, b:Integer):Integer;. Co to znaczy? Funkcja wymaga od nas wprowadzenia dwóch liczb (typu Integer), a wtedy zwraca warto¶æ ich sumy (te¿ Integer). Aby u¿yæ t± funkcjê musimy zrobiæ np: tak:<br> wynik := dodaj(199, 660);<br> Wtedy pod zmienn± wynik podstawimy warto¶æ sumy 199 i 660.<br> Powy¿ej przedstawi³em przyk³ad tworzenia funkcji. Czy¿by natomiast Delphi nie ofiarowa³ nam ¿adnej? Nie, s± i to od groma. Przyk³adow± funkcj± mo¿e by¶ StrToInt (zamiana Stringów na Integer) lub IntToStr (zamiana Integerów na Stringi). Oto ich zastosowanie:<br> liczba := StrToInt('6666666'); //zamiana String na Integer<br> tekst := IntToStr(1031203); //zamiana Integer na String<br> Dobra jeszcze przyk³ad tworzenia funkcji (teraz potêgi):</p><p class=9ptV align=left><font color=#4048A8>program Project1;<br> uses Forms;<br> var liczba1, liczba2:Integer;<br> <br> function potega(liczba, wykladnik:Integer):Integer;<br> var i:Integer;<br> begin<br> Result := 1;<br> if wykladnik = 0 then Result := 1;<br> if wykladnik = 1 then Result := liczba;<br> if wykladnik > 1 then<br> begin<br> for i:= 1 to wykladnik do<br> Result := Result*liczba;<br> end;<br> end;<br> <br> begin<br> write('Podaj a: ');<br> readln(liczba1);<br> write('Podaj wykladnik: ');<br> readln(liczba2);<br> writeln(potega(liczba1,liczba2));<br> readln;<br> end.</font></p><p class=9ptV align=justify>W funkcje mo¿na wstawiaæ pêtle, warunki i zmienne (to samo co w procedurach). Mo¿ecie zmieniaæ nazwy zmiennych w procedurach (te w nawiasach) lub dodaæ ich wiêcej (suma(a,b,c,d,e,f,g:Integer):Integer). Aby pod warto¶æ funkcji podstawiæ wynik (oczywi¶cie w funkcji, a nie poza ni±) trzeba u¿yæ zmiennej Result (bez deklarowania) lub nazwê funkcji: dodaj := a+b; Mogli¶my te¿ wynik naszej potêgi podaæ w Stringu (nie zapomnijcie do programu dodaæ w sekcji uses SysUtils, wtedy mo¿ecie korzystaæ z funkcji IntToStr):</p><p class=9ptV align=left><font color=#4048A8>function potega(liczba, wykladnik:Integer):String;<br> var i, wynik:Integer;<br> begin<br> wynik := 1;<br> if wykladnik = 0 then Result := '1';<br> if wykladnik = 1 then Result := IntToStr(liczba);<br> if wykladnik > 1 then<br> begin<br> for i:= 1 to wykladnik do<br> wynik := wynik*liczba;<br> Result := IntToStr(wynik);<br> end;<br> end;</font></p><p class=9ptV align=justify>Jak widzicie mo¿liwo¶ci jest du¿o. W procedurach te¿ mo¿na otrzymywaæ wyniki oraz podawaæ zmienne, ale ze wzglêdu na wielko¶æ tego pliku napiszê o tym pó¼niej. Je¶li macie jakie¶ pytania to walcie ¶mia³o, tylko proszê, ¿eby zaznaczyæ w mailu, ¿e chodzi o kurs Delphi (w MagaZinie of kors). Ufff... :)</p><p class=9ptV align=right><font color=#000000><b>PC3T</b><br> </font><a href=mailto:przempc@poczta.onet.pl class=link2><font color=#4048A8>przempc@poczta.onet.pl</font></a></td></tr></table></div></td></tr><tr><center><td width=100% height=20 valign=bottom></center><div align=center><table border=0 width=586 height=20 cellspacing=0 cellpadding=0><tr><td width=135 background=../img/line3.gif><p align=right><img border=0 src=../img/line.gif width=9 height=20></td><center><td width=310 valign=bottom><p align=center class=9ptV><a href=16.htm class=link2><font color=#4048A8>poprzednia strona</font></a><font color=#4048A8> :: </font><a href=spis.htm class=link2><font color=#4048A8>spis tre¶ci</font></a><font color=#4048A8> :: </font><a href=18.htm class=link2><font color=#4048A8>nastêpna strona</font></a></td><td width=135 background=../img/line3.gif><img border=0 src=../img/line2.gif width=9 height=20></td></tr></table></center></div></td></tr><tr><td width=100% height=20 valign=top>&nbsp;</td></tr><tr><td width=100% height=25 valign=middle bgcolor=#4048A8><div align=center><table border=0 width=583 cellspacing=0 cellpadding=0><center><td width=596 class=9ptV valign=bottom colspan=6><p class=9ptV align=center><font color=#FFFFFF><b>WSZELKIE PRAWA ZASTRZE¯ONE :: COPYRIGHT &copy; LOOPUSNET/MAGAZIN 2001-2002</b></font></td></center><center></table></center></div></td></tr><tr><td width=100% height=20 valign=top>&nbsp;</td></tr></table></div></body></html>